{
  "id": "68f27f4071abd9d6b34f69f9",
  "title": "Node Express Course",
  "description": "No description available",
  "learningObjectives": [
    "No learning objectives"
  ],
  "finalProjectDetails": {
    "overview": "No final project specified.",
    "planningResources": [],
    "requirements": [
      "No requirements specified."
    ],
    "submissionInstructions": "No submission instructions provided."
  },
  "createdBy": {
    "name": "Mo S Rezaie",
    "githubUsername": "msrezaie"
  },
  "contributors": [],
  "status": "pending",
  "originalGithubUrl": "https://github.com/Code-the-Dream-School/node-express-course",
  "remoteGithubUrl": "https://github.com/msrezaie/node-express-course-cb-ai2-1760725745227",
  "createdAt": "2025-10-17T17:39:12.914Z",
  "updatedAt": "2025-10-17T17:39:36.564Z",
  "lessonCount": 17,
  "lessonMetadata": [
    {
      "id": "68f27f4a71abd9d6b34f6a4e",
      "lessonNumber": 1,
      "title": "Lesson 1",
      "status": "pending",
      "assignment": {
        "title": "Example of a Windows path:",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "You should already have done the steps described in the **[Getting Started page](./getting-started-with-node-development.md)**. That page describes how to get git, the VSCode Editor, Node, and Postman all installed. All of those should be installed before you start this lesson.\n\nThe next step is to create a “fork” of your starter repository for this lesson, which is found **[here](https://github.com/Code-the-Dream-School/node-express-course)**. The fork button is on the upper right of that page. Once the fork is complete, you must `git clone` your fork to get the repository files onto your computer.\n\nCareful!\n\nPlease **don’t clone the original Code-the-Dream repository**,  \nas if you do that, you will not be able to push your work to Github.\n\n![Fork repo screenshot](https://storage.googleapis.com/ctd-course-bucket/courses/68f27f4071abd9d6b34f69f9/images/f5f23660-a964-4c5a-85fb-52753f3e99be.png)\n\n![Git clone command screenshot](https://storage.googleapis.com/ctd-course-bucket/courses/68f27f4071abd9d6b34f69f9/images/24d30db3-8dd9-4edc-983e-60443033783c.png)\n\nYou will do all of your work inside the directory created by the `git clone` command. By default, this directory will be called “node-express-course”. Change directories so that you are inside that directory. Then create the **branch** for this week, using the command `git checkout -b week1`.\n\nNow change the directory to the one that says `01-node-tutorial/answers`. You’ll do all of this week’s work inside this directory.\n\nCreate the following programs for this lesson, all within the “answers” directory. By the way, there are examples of each of the programs you need to create in the 01-node-tutorial directory (in case you get stuck) but try to do your own work. If you need to review a section of the video for any of these exercises, view the video within Youtube, but not in full screen mode. The panel on the right will show you the chapter of the video so that you know what you should review.\n\nYour homework should include the following programs:\n\n1. `01-intro.js`: This program should use the `console.log` function to write something to the screen. While you are in the “answers” directory, run the command, `node 01-intro.js`, to verify that the program runs. You can also put additional JavaScript logic in your program.\n2. `02-globals.js`: This program should use the `console.log` function to write some globals to the screen. Set an environment variable with the following command in your command line terminal: `export MY_VAR=\"Hi there!\"` The program should then use `console.log` to print out the values of `__dirname` (a Node global variable) and `process.env.MY_VAR` (`process` is also a global, and contains the environment variables you set in your terminal.) You could print out other globals as well ([Node documentation](https://nodejs.org/api/globals.html#global-objects) on available globals). For each of these programs, you invoke them with `node` to make sure they work.\n3. For the next part, you will write multiple programs. `04-names.js`, `05-utils.js`, `06-alternative-flavor.js`, and `07-mind-grenade.js` are modules that you load, using require statements, from the `03-modules.js` file, which is the main program. Remember that you must give the path name in your require statement, for example:\n\n```javascript\nconst names = require(\"./04-names.js\");\n```\n\n(3a). `04-names.js` should export multiple values in an object that you will require in `03-module.js`.\n\n(3b). `05-utils.js` should export a single value, which is a function you will call in `03-modules.js`.\n\n(3c). `06-alternative-flavor.js` should export multiple values in the module.exports object, but it should use the alternative approach, adding each value one at a time. The exported values from each should be used in `03-modules.js`, logging results to the console so that you know it is working.\n\n(3d). `07-mind-grenade.js` may not export anything, but it should contain a function that logs something to the console. You should then call that function within the code of `07-mind-grenade.js`. This is to demonstrate that when a module is loaded with a require statement, anything in the mainline code of the loaded module runs.  \n**NOTE**: The only program you should need to actually invoke to test that everything is working is `03-modules.js`, because it loads all the others (files 4-7).\n\n1. `08-os-module.js`: This should load the built-in `os` Node module and display some interesting information from the resulting object. As for all modules, you load a reference to it with a require statement, in this case\n\n```javascript\nconst os = require(\"os\");\n```\n\nYou can look **[here](https://nodejs.org/api/os.html)** for documentation on the stuff in the built-in os module.\n\n1. `09-path-module.js`: This should load the `path` Node module, which is another built-in module. It should then call the `path.join` function to join up a sequence of alphanumeric strings, and it should print out the result. The result will work one way on Windows, where the directory separator is a backslash, and a different way on other platforms, where the directory separator is a slash.\n\n```\n# Example of a Windows path:\nC:\\Users\\JohnSmith\\node-express-course\\01-node-tutorial\\answers\n\n# Exmaple of a Mac or Linux path:\n/Users/JohnSmith/node-express-course/01-node-tutorial/answers\n```\n\n1. `10-fs-sync.js`: This should load `writeFileSync` and `readFileSync` functions from the `fs` module. Then you will use `writeFileSync` to write 3 lines to a file, `./temporary/fileA.txt`, using the `\"append\"` flag for each line after the first one. Then use `readFileSync` to read the file, and log the contents to the console. Be sure you create the file in the `temporary` directory. That will ensure that it isn’t pushed to Github when you submit your answers (because that file has been added to the `.gitignore` file for you already which tells git not to look at those files).\n2. `11-fs-async.js`: This should load the `fs` module, and use the asynchronous function `writeFile` to write 3 lines to a file, `./temporary/fileB.txt`. Now, be careful here! This is our first use of **asynchronous functions** in this class, but we are going to use them a lot! First, you need to use the `\"append\"` flag for all but the first line. Second, each time you write a line to the file, you need to have a callback, because the `writeFile` operation is asynchronous. Third, for each line you write, you need to do the write for the line that follows it within the callback – otherwise the operations won’t happen in order. Put `console.log` statements at various points in your code to tell you when each step completes. Then run the code. Do the console log statements appear in the order you expect? Run the program several times and verify that the file is created correctly. Here is how you might start:\n\n```javascript\nconst { writeFile } = require(\"fs\");\nconsole.log(\"at start\");\nwriteFile(\"./temporary/output.txt\", \"This is line 1\\n\", (err, result) => {\n  console.log(\"at point 1\");\n  if (err) {\n    console.log(\"This error happened: \", err);\n  } else {\n    // here you write your next line\n  }\n});\nconsole.log(\"at end\");\n```\n\nTo get the lines to be written in order, you end up with a long chain of callbacks, which is called “callback hell”. We’ll learn a better way to do this soon.\n\n1. `12-http.js`. This program should use the built-in `http` module to create a simple web server that listens on port 3000\\. This is done with the `createServer` function. You pass it a callback function that checks the request variable (`req`) for the current `url` property, and depending on what the URL is, sends back a message to the browser screen. Then have your code listen on port 3000, run this file with the `node` command, and test it from your browser, by navigating to `http://localhost:3000`. You can look at `12-http.js` for the instructor’s answer (except that program listens on 5000). You will need to type in Ctrl+c (the Ctrl key plus the letter “C” at the same time; or for Mac the Cmd key plus the letter “C” at the same time) to exit your program.\n2. Within your “answers” directory is a program called `prompter.js`. This is a program for a simple server. Try it out! It will display a form in the browser when you run the file and navigate to `http://localhost:3000`. Then, when the user submits the form, it echoes back what was submitted, and displays the form again. You don’t have to worry about how it works. There is a simple body parser to read any values submitted with the form, and that parser returns a hash with the name and value of each. Because the parser is asynchronous, you get back the hash in a callback.  \nNow, your task is to change this program so that it does something interesting! First, you can change the variables that you want to store when you get the form back. Then, you can change the form itself to return the values you want from the user, which you store in those variables. Then, you can use string interpolation to insert the values of your variables into the HTML. Finally, you change the logic that handles the hash of values you get when the user submits the form, so that you save the values the user submits. The places you would change are marked in the code.  \nFor example, you could change the input field to be a dropdown with various colors, and you could set the background color of the body to be what the user chooses. Or, you could make a number guessing game: Start with a random number from 1 to 100, let the user guess, and tell the user if their guess is low or high. In this case, you’d change the input field so that it accepts only numeric input (but when it is returned in the hash, it will be a string, so you’d have to convert it.)\n\nWhen you are done, change directories to the `01-node-tutorial` folder and then do the following to submit your work:\n\n```\ngit commit add ./answers\ngit commit -m \"answers for lesson 1\"\ngit push -u origin week1\n```\n\nThen go to your GitHub repository – the one you created with a fork (the URL should have your Github username in it). Create a pull request. You may see a yellow banner on your repository if you recently pushed your change, where you can click the “Compare & pull request” to create a PR. Otherwise, you can switch to your branch in the dropdown on the repo page, and then click the pull request icon to create a PR that way.\n\nCareful!\n\nThe target of the pull request should be the main branch of the repository  \nyou created when you forked —  \n**not the Code-the-Dream-School main branch!**\n\nOnce you have created the pull request, you can copy the URL to link the pull request in your homework submission form. The homework submission form is on the main page for this lesson. This will be the general procedure for submitting homework for this course.\n\n<video title=\"Open a PR walkthrough\" src=\"./images/submit-pr.mp4\" controls=\"controls\" width=\"300\" height=\"150\"></video>\n\nWhen you submit your homework, you also submit your answers to the mindset assignment, if there is one for that lesson.",
            "codeExample": "",
            "_id": "68f27f4a71abd9d6b34f6a50"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Lesson 1",
          "content": "A simple introduction to Node is available at **[this link](https://www.youtube.com/watch?v=uVwtVBpw7RQ)**. Just watch the first video in the series.\n\nBe aware of this **[descriptive introduction to Node](https://medium.com/@frankstepanski/beginning-node-and-express-3482238c5c94)**, by our staff member Frank. There are a number of sections that are too technical for now, but you may want to refer to it in the future.\n\nWatch the first 1:45:57 of **[this video](https://www.youtube.com/watch?v=Oe421EPjeBE)**. You may first want to review the coding assignment below. In your assignment, you create programs similar to those  \nthat the instructor demonstrates.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4a71abd9d6b34f6a4f"
        }
      ]
    },
    {
      "id": "68f27f4a71abd9d6b34f6a52",
      "lessonNumber": 2,
      "title": "Lesson 2",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 2",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "For week 1, you created files in the `node-express-course/01-node-tutorial/answers` directory. For week 2, you’ll continue to do your work in that same directory. However, before you do your work for this week, you must switch to a new git branch. While the week1 branch is active, use the command\n\n```\ngit checkout -b week2\n```\n\nAs you will be working on the `node-express-course` repository for some weeks, this is the way you separate your assignments for each week. The key topics in this section are:\n\n* how to use `npm` and the `package.json` file to manage a Node project and its dependencies\n* async patterns\n* event emitters and handlers\n* streams\n\nThe instructor does provide examples if you need them. Just like the previous lesson, you will work in the `answers` directory within the `01-node-tutorial` directory. Follow these steps:\n\n1. Within your answers directory, create a file called `.gitignore`. It should have the following lines:  \n```  \n/node_modules  \n.DS_Store  \n```  \nYou do not want to store the contents of `node_modules` in Github, because they are already present on the web as public files, accessible by npm. As well, the `node_modules` folder can get very large, which would slow down our git operations if we include it. The `.DS_Store` file is sometimes created by the Mac operating system, and you don’t need that one in Github either.\n2. Within your `answers` directory, run the command `npm init`. You can accept all the defaults, except you can enter your name when it prompts you for author. This creates a `package.json` file.\n3. Enter the following command:  \n```  \n    npm install nodemon --save-dev  \n```  \nAs the instructor has described, `npm` gives you access to a large library of reusable code, available at [npmjs.com](https://www.npmjs.com/). You have just installed one package, but you have also installed all its dependencies, and they are all stored in the `./node_modules` directory. You can see what you have installed by looking at package-lock.json (which is automatically generated and updated whenever you install, update, or remove packages). You will never need to manually modify the `package-lock.json` file, though you _can_ make changes to the `package.json` file. The package you’ve just installed `nodemon`, is very useful for development, but you wouldn’t want to deploy it to the cloud, as it is not useful in production, so it is installed as a “dev dependency”.\n4. Edit the `package.json` file. This file manages your project, enabling others to contribute and also providing a means to deploy the project to the cloud. You can read a description of package.json [here](https://nodesource.com/blog/the-basics-of-package-json-in-node-js-and-npm/). There is one other entry that is often useful, called engines. This can be used to specify which version of node your package requires. But for now, you are just going to set up the scripts stanza. Edit it to look like the following:  \n```  \n      \"scripts\": {  \n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",  \n        \"dev\": \"nodemon prompter.js\",  \n        \"start\": \"node prompter.js\"  \n      },  \n```  \nThe scripts give npm commands you can run as you develop. In this case, the command, `npm run dev` will run the code in the `prompter.js` file, using the `nodemon` library. `nodemon` will basically just run the file with `node`, and if you make any changes to the program, `nodemon` will automatically restart node for you so that it’s running the updated code. This is useful to test continuously as you are changing your program. The command `npm run start` or just `npm start` runs the program under `node`, which is how it would run in production.\n5. From within your terminal, while you are in the `answers` directory, run the command `npm run dev`. The prompter program starts, and you can access the page from http://localhost:3000 in your browser. Now edit `prompter.js` and add a comment. Nodemon restarts the program, because `prompter.js` has changed. As before, you use Ctrl+c to end the program. Nodemon is only important for programs that keep running until you press Ctrl+c. It is not needed for programs that end by themselves.\n\nNow for some code. The instructor showed several patterns for JavaScript asynchronous programming. An asynchronous Javascript function returns a [Promise](https://javascript.info/promise-basics), or in some cases a “thenable” which acts like a Promise. You need to resolve the Promise in order to get the actual return value. To resolve a Promise inside an `async function`, you use the keyword, `await`. This should be used inside a `try/catch` block so that you can handle any errors, as follows:\n\n```javascript\nconst myFunc = async () => {\n    ...\n    return result\n}\n\nconst myFunc2 = async () => {\n    try {\n       result = await myFunc()\n       ...\n    } catch(err) {\n        console.log(\"An error occurred: \", err)\n    }\n}\n```\n\nSometimes you need to call an async function from within another function that  \nis not async. In this case, you can’t use `await` – it will give a  \nsyntax error. So you can either use `.then` or you can wrap the  \nfunction call as follows:\n\n```javascript\nconst myFunc3 = () => {  // not async, and in some contexts we better not make it async\n   myFunc()\n   .then((result) => {\n      console.log(\"got the result.\")\n      ...\n   })\n   .catch((error)=> {\n      console.log(\"An error occurred: \", error)\n   })\n}\n\nconst myFunc4 = () => {  // the other way to do it, via a wrapper:\n    const myFunc5 = async () => {\n        try {\n               result = await myFunc() {\n               console.log(\"got the result.\")\n               ...\n            }\n        } catch(error) => {\n            console.log(\"An error occurred: \", error)\n        }\n    }\n    myFunc5() // here's where we call the wrapper, but do NOT do this:\n    // result = myFunc5()  This won't work because myFunc5 is asynchronous!\n    // All you'd get back is a Promise, not the result.\n}\n```\n\nThere’s one more trick with the `.then`. Suppose you need to make a string of calls to async functions. You can chain the `.then` statements as follows:\n\n```javascript\nconst myFunc6 = () => {\n  myFunc() // an async function, so it returns a promise\n    .then((result) => {\n      console.log(\"got the first result\");\n      return myFunc(); // here we call it again, we return the promise myFunc returns\n    })\n    .then((result) => {\n      console.log(\"got the second result\");\n    })\n    .catch((err) => {\n      console.log(\"An error occurred: \", err);\n    });\n};\n```\n\nSo, you can chain a collection of async calls with `.then`  \nstatements, followed by one `.catch` at the end.\n\nOk, that’s the summary. Be sure that you understand this. We will do a lot of asynchronous programming in Express.\n\n---\n\nNow for the programs to write for this assignment:\n\n1. Create a program named `writeWithPromisesAwait.js` inside the `01-node-tutorial/answers` folder. We are going to use the fs.promises package. `fs` is the built-in “File system” set of functions in [Node](https://nodejs.org/api/fs.html#promises-api). By adding `.promises` we’re going to access the versions of those built-in functions that return a Promise as their result. You’d start with the following code:  \n```  \nconst { writeFile, readFile } = require(\"fs\").promises;  \n```  \nThen create an `async function` called `writer` that takes 0 arguments, and that writes three lines to a file named temp.txt, by calling the `writeFile` function with `await`. The Promise version of `writeFile` takes the same arguments as the one you used in last week’s exercise `10-fs-sync` but will return a Promise instead of a result directly.  \n**Put the await statements inside a `try/catch` block!**  \nCreate another async function called `reader` that reads the file with `await readFile` and logs the return value to the screen.  \nNow we want to call the two functions in order, first the writer, and the reader. But, be careful! These are asynchronous functions, so if you just call them, you don’t know what order they’ll occur in. And you can’t use await in your mainline code. So, you write a third async function called `readWrite`. In that function, you call await reader and await writer. Finally, write a line at the bottom of the file that calls the `readWrite` function. Test your code. The temp.txt file that your code is creating should not be sent to Github, so you should add this filename as  \nanother line to your `.gitignore.`\n2. Write another program called `writeWithPromisesThen.js` also in the `01-node-tutorial/answers` folder. Again you write to temp.txt. You start it the same way, but this time, you use the `.then` style of asynchronous programming. You don’t need to create any functions. Instead, you just use cascading .then statements in your mainline, like this:  \n```javascript \n writeFile(...) // write line 1  \n .then(() => {  \n    return writeFile(...)  // write line 2.  \n    // Return the promise so you can chain the .then statements  \n })  \n .then // write the third line, and follow that with two more .then blocks,  \n // one to call readFile to read it back out, and one to log the data to the screen.  \n ...  \n .catch((error) => {  \n     console.log(\"An error occurred: \", error)  \n })  \n```  \nTest your code by running `node writeWithPromisesThen.js`. You may  \nwant to sprinkle console.log statements in your code so that you understand  \nthe order of execution.\n3. We want to understand event emitters. First, modify `prompter.js`, to add the following lines above the listen statement:  \n```javascript  \nserver.on(\"request\", (req) => {  \n  console.log(\"event received: \", req.method, req.url);  \n});  \n```  \nThen test this (`npm run dev`) and try with your browser to see the events the server is emitting.\n4. Write a program named `customEmitter.js` in the `01-node-tutorial/answers` folder. In it, create one or several emitters. Then use the emitter `.on` function to handle the events you will emit, logging the parameters to the screen. Then use the emitter `.emit` function to emit several events, with one or several parameters, and make sure that the events are logged by your event handlers. This is your chance to be creative! You could have an event handler that emits a different event to be picked up by a different handler, for example. Here’s a couple tricks to try. You can trigger events with a timer, as follows:  \n```javascript  \nconst EventEmitter = require(\"events\");  \nconst emitter = new EventEmitter();  \nsetInterval(() => {  \n  emitter.emit(\"timer\", \"hi there\");  \n}, 2000);  \nemitter.on(\"timer\", (msg) => console.log(msg));  \n```  \nOr, you could make an async function that waits on an event:  \n```javascript  \nconst EventEmitter = require(\"events\");  \nconst emitter = new EventEmitter();  \nconst waitForEvent = () => {  \n  return new Promise((resolve) => {  \n    emitter.on(\"happens\", (msg) => resolve(msg));  \n  });  \n};  \nconst doWait = async () => {  \n  const msg = await waitForEvent();  \n  console.log(\"We got an event! Here it is: \", msg);  \n};  \ndoWait();  \nemitter.emit(\"happens\", \"Hello World!\");  \n```  \n(Don’t worry if that last one looks a bit complicated. That’s expected as we  \nhaven’t talked about creating promises yet.)\n5. Change back to the `01-node-tutorial` directory and run `15-create-big-file.js`. This creates a big file in the content directory. You’ll note that the instructor has a `.gitignore` that includes the file name that’s created by that code so that it isn’t stored in Github.\n6. Now, change back to the `answers` directory, and write a program called `16-streams.js`. It should create a read stream for the big file (`../content/big.txt`) with encoding of `\"utf8\"` and a `highWaterMark` of `200`. The `highWaterMark` is the maximum amount of bytes that node will read with each chunk of the stream. The program should initialize a counter to 0\\. Then it should handle the `“data”` event for the stream by incrementing the counter and logging the event result to the screen. Then it should handle the `“end”` event by reporting the number of chunks received. Finally, it should handle the stream `“error”` event by logging the error to the console. Test the program for several values of highWaterMark. You can look at `01-node-tutorial/16-streams.js` file to help you as needed.\n7. Have a look at `17-http-stream.js`. You don’t need to write a program, but observe how the chunks that are read from the stream are piped to the `res` object that is returned from the http request. Try to understand this program. Usually, if you are sending back voluminous data in response to an HTTP request, you want to break it up into chunks.\n\nThat’s all for this week, great job! Note, that while the `01-node-tutorial` folder has files for `13-event-emitter.js` and `14-request-event.js`, we’ve substituted those with the event emitter work in this week’s assignment and the `prompter.js` work in the previous assignment. You can still feel free to follow along with the video and complete those files if you’d like.\n\nWhen you have completed your programming assignment, do a `git add` for all your changes to the branch, commit the changes, and push the changes to your repository. Then create a pull request. A link to the pull request is to be included in your homework submisson.",
            "codeExample": "",
            "_id": "68f27f4a71abd9d6b34f6a54"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Lesson 2",
          "content": "This lesson covers how to use the node package manager npm to install additional modules from the npm library. It also covers event processing and async patterns in node. There are several introductory videos to watch. **[This link](https://medium.com/@mmoshikoo/event-loop-in-nodejs-visualized-235867255e81)** and **[this video](https://www.youtube.com/watch?v=8aGhZQkoFbQ)** cover the event loop, and are referred to as external resources in the main video. **[This video](https://www.youtube.com/watch?v=cFTFtuEQ-10)** covers try/catch/throw error handling in JavaScript, which is critical when writing asynchronous code. You continue watching **[this video](https://youtu.be/Oe421EPjeBE?t=6357)**. This week, you watch from 1:45:57 of the video to 3:40:46\\. As before, the video is broken up into chapters, so that you can review chapters as needed to complete the programming assignment. **Important:** At about 2:03 of the video, the instructor does some git operations. **Do not do these.** You do need to create the .gitignore file, but you definitely do not do a git init inside the answers directory. That would create a git repository nested within your existing repository, which is a mess. In general, in this and all future videos, ignore any git operations the instructor performs. You already have the git repository you need.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4a71abd9d6b34f6a53"
        }
      ]
    },
    {
      "id": "68f27f4a71abd9d6b34f6a56",
      "lessonNumber": 3,
      "title": "Lesson 3",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 3",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "The basic elements of an Express.js program are as follows:\n\n* The `require` statement to import the `express` module\n* Creation of the app as returned from calling `express()`\n* `app.use` statements for the middleware. You’ll eventually use many kinds of middleware, but for now the only middleware we are using is `express.static()`.\n* `app.get` and `app.post` statements for the routes you will handle. Eventually these will be refactored into router modules, but for now you can put them inline.\n* An `app.all` statement after these to handle page not found conditions.\n* An `app.listen` statement to tell the server to listen for requests on a particular port.\n\nYou continue working in the node-express-course repository, but for this week, you switch to the 02-express-tutorial directory. This week introduces the Express npm package, which makes web development much quicker than using Node alone. There is no need to use an answers folder. You just put your work in the 02-express-tutorial folder. Complete the following steps:\n\n1. While the `week2` branch is active, create a `week3` branch, for this week’s work (`git checkout -b week3`).\n2. While you are in the `02-express-tutorial` folder, run `npm install`. The instructor has provided a `package.json` and a `.gitignore`. The `package.json` already has the express package defined in it, so running the command `npm install` will do the installation of that package, as needed for this week’s work.\n3. Create a folder named `public` within `02-express-tutorial`. Create an HTML file within it called `index.html`. It’s not critical what you put in the HTML file – just something simple.\n4. Edit `app.js` to add all the elements of an Express application as listed above, in the right order. You won’t have any `app.get` or `app.post` statements yet. You should have the statement `app.use(express.static(\"./public\"))` so that your HTML file will load. Use port 3000 in the listen statement.\n5. Start the server, with `npm start`. Then use your browser to load http://localhost:3000. You should see the HTML page you created.\n6. Try the URL http://localhost:3000/not-there. You should see that your `app.all` for page not found returns a 404 error.\n7. For the next part, you will implement APIs that return JSON. Because you are using the browser to display the JSON, you may want to add a JSON formatter plugin into your browser ([here’s one for Chrome](https://chrome.google.com/webstore/detail/jsonvue/chklaanhfefbnpoihckbnefhakgolnmc), for example), so that it’s easier to view. Add an `app.get` statement to `app.js`. It should be _after_ the Express static middleware, but _before_ the “not found” handler. It should be for the URL `/api/v1/test`. It should return JSON using the following code:\n\n```javascript\nres.json({ message: \"It worked!\" });\n```\n\nTry that URL from your browser, and verify that it works.\n\n1. Next, we want to return some data. We haven’t learned how to access a database from Express yet, so the instructor has provided data to use. It is in `data.js`, so have a look at that file. Then add the following require statement to the top of the program:\n\n```javascript\nconst { products } = require(\"./data\");\n```\n\nThe value of the products variable is an array of objects from  \n`data.js`, which are various items of furniture. We now want to  \nreturn this array. So add an `app.get` statement for the url  \n`/api/v1/products`. Write some code to return JSON for the products  \narray. Test the url with your browser.\n\n1. Next, you need to provide a way to retrieve a particular product by ID. This is done by having an `app.get` statement for the url `/api/v1/products/:productID`. The colon in this url means that `:productID` is a _parameter_. So, when your server receives the GET request for a URL like `/api/v1/products/7`, `req.params` will have the hash `{ productID: 7 }`. Try this out by creating the `app.get` statement and doing a `res.json(req.params)` to return the path parameter in the HTTP response itself.\n2. Of course, the API should actually return, in JSON form, the product that has an ID of 7\\. So you need to find that product in the array. For that, you use the `.find` [function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/find) of the array:\n\n```javascript\nconst idToFind = parseInt(req.params.productID); \nconst product = products.find((p) => p.id === idToFind);\n```\n\nThe parseInt is needed because query parameters are always passed as strings, so you have to convert this to an integer. Change the app.get statement so that it returns JSON for the product. Test it out.\n\n1. The user may request a product that is not there, for example with a URL like `/api/v1/products/5000` or `/api/v1/products/nottthere`. So in that case, you should return a 404 status code and the JSON `{ message: \"That product was not found.\"}`. Add this logic to the `app.get` statement, and test that it works.\n2. The user may also want to do a simple search, instead of getting all the products. In this case, the url would contain a query string, like: `/api/v1/query?search=al&limit=5`.  \nWhat this means, in this case, is that the user wants to see all products where the name starts with “al”, but the user wants to see no more than 5 products. When the `app.get` for `/api/v1/query` path is called, `req.query` is a hash that may contain values for “search” or “limit” or both or neither, depending on what the user puts in the query string. Again, there are array methods you can use to find that list. They are `Array.filter()` and `Array.slice()`. Add a new `app.get` statement for `/api/v1/query`, and include logic to handle these query strings. Then test it out.\n3. Add some more logic: you choose! For example, the user might want to send a regular expression instead of search for starting letters. Or the user may only want products that cost less than 20.00.\n4. Optional additional item: Add a button to your `index.html`. Add JavaScript, either within a `<script>` tag in `index.html` or in a JavaScript file it references (which would also be in the public directory.) When you click the button, your JavaScript would issue a fetch call for `/api/v1/products`. Then you’d add the data you get back to a div in your HTML.\n\n## Bonus Assignment\n\nIn the `node-express-course/week_3_alt_assignment` directory, a sample express application is provided. This is to give you a chance to do something creative with Express! Completion of the assignment is optional.The goals of the lesson are in the `README.md` in that folder, and the instructions are in `index.js`. You should first run the sample. You can then follow the instructions to create your own simple game. You’d give your file a name like `app.js` (also within the same directory, and you’d change the `package.json` so that the start command runs `app.js` instead of `index.js`. The example shows how HTML returned by the application can be made dynamic, through string interpolation. We’ll learn another way to return dynamic HTML later in the course. You should certainly run the sample application, as it explains important concepts. Creation of your own game is optional, but recommended.",
            "codeExample": "",
            "_id": "68f27f4a71abd9d6b34f6a58"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Lesson 3",
          "content": "You continue watching **[the lesson video from last week](https://youtu.be/Oe421EPjeBE?t=13246)**. This week, you watch from 3:40:48 of the video to 6:10:46.\n\nThis section of the video starts with some slides on how the web works. You do not need to write any code for these slides. Then, at about 3:56:00 of the video, the instructor starts talking about how you download the repository containing the code. **Do not do this.** You already have the code you need, as it is included in the same repository you are using. The instructor also directs you to remove the .git directory. **Do not remove the .git directory.** Because you forked the original repository, you continue to use the git configuration.\n\nThe useful parts of the video resume about 3:58:00\\. At about 5:18:13 of the video, the instructor discusses APIs compared with Server Side Rendering. Server Side Rendering is covered towards the end of this course. This section of the course focuses on simple responses, serving static files, and developing APIs. The APIs you develop in this class are built according to an approach called REST, which stands for Representational State Transfer. In addition, the implementation this class teaches for REST uses HTTP requests with the methods/operations:\n\n* Get\n* Post\n* Put\n* Patch\n* Delete\n\nEach operation goes to a particular URL, and there may be parameters in the URL as is explained in the lesson. In addition, the `POST`, `PUT`, and `PATCH` operations may pass along JSON data in the body of the request. JSON data is returned from the server in the body of the response. (It is possible to write APIs that don’t use JSON, but in this class JSON is always used.) If you need to learn or review JSON, a basic introduction is at this link: <https://www.digitalocean.com/community/tutorials/an-introduction-to-json>",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4a71abd9d6b34f6a57"
        }
      ]
    },
    {
      "id": "68f27f4a71abd9d6b34f6a5a",
      "lessonNumber": 4,
      "title": "Lesson 4",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 4",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "For this lesson, you continue to work in the `node-express-course/02-express-tutorial` directory. As usual, you should use git to switch to a new branch, the `week4` branch _from_ the `week3` branch, before you start your work. However, there is a potential hitch. Suppose your `week3` branch has not been approved by your reviewer? You are going to continue to work on `app.js`, so your new changes might conflict with any changes that the reviewer requests. There are various ways to solve this problem, having to do with resolution of merge conflicts. One is as follows:\n\n* Add and commit the changes you have made so far to the `week4` branch.\n* Checkout `week3`.\n* Make the changes requested by your reviewer, and add, commit, and push them. This adds them to your PR.\n* Checkout `week4`.\n* Do: `git merge week3 -m \"merge of changes to previous week lesson\"`. This brings in all the changes from `week3` into your `week4` branch.\n\nAt this point, you may get a merge conflict. This happens if there are changes to the same lines in the files in both the `week3` branch that you’re trying to merge in and the `week4` branch that you’re currently in. Git doesn’t know which versions of those lines you want to keep If you know how to resolve merge conflicts, this is the best way to proceed. If you do not know how to resolve merge conflicts, you will need to learn it sooner or later. There is a good tutorial **[here.](https://www.youtube.com/watch?v=lz5OuKzvadQ)** But, here is an alternate procedure:\n\n* Add and commit your changes to the `week4` branch.\n* Checkout `week3`, make the changes required, and add, commit, and push.\n* Checkout `week4`\n* Do: `git checkout week3 -- app.js >apptemp.js`. This takes the version of app.js from the `week3` branch and puts it in a file called `apptemp.js`.\n* Copy the changes you need from `apptemp.js` to `app.js`, and then erase `apptemp.js`\n\nMake the following changes to `app.js` and related files. (Note that examples of code that perform these functions are available in the `final` directory.) First, create a _middleware function_ called `logger` in `app.js`. A middleware function is passed `req` and `res` as its first two parameters, just like an `app.get` call, but it is also passed a third parameter, `next`. The next() function must be called once middleware processing is completed, otherwise no response is sent back for the request. The middleware function you create should log the `method` and `url` properties from the `req` object, as well as the current time, before calling `next()`. Middleware functions are called in two ways. First, you can insert them into your route statements, as follows:\n\n```javascript\napp.get('/', logger, (req, res) => {\n    ...\n})\n```\n\nThis means the `logger` middleware function will run before any `GET` request to the `/` path.  \nThe second way to invoke middleware is via an `app.use()` statement:\n\n```javascript\napp.use([\"/path1\", \"/path2\"], logger);\n```\n\nIn this case, the first argument is a path or an array of paths indicating the urls for which the middleware is called. This argument is optional. If you leave it out, it is called for _**all**_ urls. When using an `app.use()` statement, order is important! For example, if you put `app.use(express.json())` after your `app.post()` statement, the `app.post()` won’t work as expected, because the body will not have been parsed into JSON yet. Call your logger using the first method, in one of your `app.get()` statements, and verify that it works. Then, take the logger call out of your `app.get()` statement, and call it via `app.use()`, for all paths, instead. Verify that it still works.\n\nNext, you need to implement some APIs for people. You have a require statement for `./data.js` that gets the value of products. Get the value for people, also from `./data.js` (add this in the same require statement). Then implement an `app.get` for `/api/v1/people`. Test it with your browser. You are returning JSON, so you call res.json(…) to send the data back. You now need to implement an `app.post` for `/api/v1/people`. This is to add an entry to the people array. Post operations are sent from the browser with a “request body”. You need to add middleware to parse this body into a Javascript object. The following statements do this parsing, returning the result as a hash in `req.body`.\n\n```javascript\napp.use(express.urlencoded({ extended: false }));\napp.use(express.json());\n```\n\nThe first of these parses url-encoded data, which is the format that is sent by an HTML form. This is not typically needed if you are only implementing a JSON API. The second statement parses a JSON body. You need these statements before your `app.post()` statement, so that the body is parsed before you do the rest of the processing. Now you implement the `app.post` statement for `/api/v1/people`. The statement should check `req.body` to see if there is a `req.body.name` property. If not, it should return JSON for an error, as follows:\n\n```javascript\nres.status(400).json({ success: false, message: \"Please provide a name\" });\n```\n\nThis sets the HTTP result code to [400](https://http.dev/400), which means there was an error on the client side, and also returns an error message. But suppose there is a value in req.body.name. You want to add this entry to the people array, as follows:\n\n```javascript\npeople.push({ id: people.length + 1, name: req.body.name });\nres.status(201).json({ success: true, name: req.body.name });\n```\n\nThe HTTP status code [201](https://http.dev/201) means that an object was created on the server side. Of course, as there is no database, this data will be gone when you restart the server.\n\nNow is the time to test it out using Postman. Create a Postman GET request for `/api/v1/people` and verify that that works. Then create a Postman POST request for `/api/v1/people`. Choose the ‘raw’ form of the body, and select JSON from the pull-down. Put a JSON object with a name in the body, and verify that that works. Do the GET request again from Postman, to verify that the person is added to the array. Try the POST request with an invalid body as well. The instructor has provided a sample front end, and you can try this as well. Change the directory for your static serving from `./public` to `./methods-public`, and try out that frontend from your browser.\n\nThe next step is refactoring. You do not want too much logic in the `app.js` file. Create directories called routes and controllers. Create a file called `routes/people.js`. It should start with the following statements:\n\n```javascript\nconst express = require(\"express\");\nconst router = express.Router();\n```\n\nYou then need to add a `router.get()` statement for the `\"/\"` path. This should do the same thing as your `app.get(\"/api/v1/people\")` statement. Similarly, you need a `router.post()` statement for `\"/\"`. Finally, at the bottom, you need `module.exports = router`. You now need to add a require statement in the `app.js` file, to import the `peopleRouter` code. Then you need the following `app.use()` statement, also in app.js:\n\n```javascript\napp.use(\"/api/v1/people\", peopleRouter);\n```\n\nBe careful that this `app.use` statement comes _after_ the parsing of the body, or stuff won’t work as expected. Then comment out your `app.get` and `app.post` statements for `/api/v1/people`. Test the result using Postman, fixing bugs as needed. The refactoring is not yet done. You need to create the file `controllers/people.js`. That should start with a require statement that gets the people array from `../data.js`. Then create functions `addPerson` and `getPeople`. These are each passed `req` and `res`. Copy the logic from your `router/people.js` file, for both the GET and the POST. Then export `{ addPerson, getPeople }`. Then require them in your `routes/people.js`, as follows:\n\n```javascript\nconst { addPerson, getPeople } = require(\"../controllers/people.js\");\n```\n\nThen change the `router.get` and `router.post` statements to call these functions, instead of doing the processing inline. Test again using Postman. You could also refactor the products routes, but it is not required for this assignment. Add a `router.get` statement to `routes/people.js`. This is to get a particular entry from the people array. You need an `id` parameter, so the path should have `/:id`. Then write code so that, if the array includes a people entry with a matching id, a JSON object with that entry is returned (return code [200](https://http.dev/200)). You can use `Array.find()`, but `req.params.id` will be a string, so you”ll have to convert it to an integer first. If the entry is not found, return an error [404](https://http.dev/404) with JSON that has an appropriate message. Test this with Postman.\n\nThen move the logic for the statement to `controllers/people.js`, and update the `module.exports` statement in that file, as well as the require statement in the `routes/people.js`, so that the route calls the controller function you create. Add a `router.put` statement to `routes/people.j`s to update the people entry if it is found, and to return an error if it isn’t. The processing for this should be in the controller. Do a `router.delete` statement as well. Test these using Postman. For the delete, you might use `Array.filter()` to create the updated people array.\n\n## Optional Additional Assignment\n\nThis optional assignment gives some idea of how authentication might work. You will use the `cookie-parser` npm package, so do an `npm install` for that package. Cookies are set, typically by the back end, the browser then stores them and attaches them to each subsequent request. This allows us to add some “state” to each HTTP request. That is, the browser and backend can ‘remember’ some information automatically across requests, like for example, which user is making these requests. Add to `app.js` a require statement for `cookie-parser`. Then, right after you parse the body of the request, add a statement to parse the cookies:\n\n```javascript\napp.use(cookieParser());\n```\n\nNow write a middleware function called `auth`. This checks for `req.cookies.name`. If that cookie is present, it sets` req.user` to the value, and calls `next`. If it is absent, it sets the res status to [401](https://http.dev/401) (which means unauthorized), and returns a message in a JSON object that says “unauthorized”. It **_does not_** call `next()` in this case. (Typically middleware would throw an error at this point, instead of returning a result.) Now add an `app.post(\"/logon\")`, which should require a name in the body. If it is present, it should do a `res.cookie(\"name\", req.body.name)`, and send back a 201 result code plus a message that says hello to the user. If name is not present, it should return a 400 and an error message in JSON. Now add an a`pp.delete(\"/logoff\")`. This should do a `res.clearCookie(\"name\")`, and then it should return a 200, with a message in JSON that the user is logged off. Now add an `app.get(\"/test\")`. The auth middleware should be invoked in this `app.get` statement. The get should just return a 200, plus a message in JSON that says welcome to the user, whose name is in `req.user`. Then test this with Postman. You should be able to logon, logoff, and test, and the test should do something different depending on whether or not you are logged in.\n\nWhen you have completed your programming assignment, git add, git commit, and git push your branch, and create a pull request, so that you can include a link to your pull request in your homework submission.",
            "codeExample": "",
            "_id": "68f27f4a71abd9d6b34f6a5c"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Lesson 4",
          "content": "You will finish watching **[the video from the last few weeks](https://youtu.be/Oe421EPjeBE?t=13246)**. This week, you watch from 6:10:46 of the video to the end. The initial focus is on middleware. Then each of the HTTP methods involved in API development are covered: `GET`, `POST`, `PUT`, `PATCH`, and `DELETE`. As routes for each of these API methods are implemented, you will test them using Postman. You then refactor the code, to separate out the router and controller functions.\n\nThe front end calls the APIs in two ways, first as browser `GET` and `POST` requests coming from a standard HTML page, and second via JavaScript in the browser that issues `GET`, `POST`, `PUT`, and `DELETE` requests. You can find the front end in the `methods-public` directory. Study the two HTML files in this directory. They show you how to call the back end from the front end, using either ordinary HTML or JavaScript. When ordinary HTML is used, only GET and POST requests are supported, because those are the only operations a browser can natively do; and the `POST` request sends form-encoded data. When JavaScript is used, all HTTP operations are supported, and JSON is used to send and receive data. Parsing of the body of the request, for form-encoded and JSON data, is explained in the video.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4a71abd9d6b34f6a5b"
        }
      ]
    },
    {
      "id": "68f27f4a71abd9d6b34f6a5e",
      "lessonNumber": 5,
      "title": "Lesson 5",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 5",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "### Warm Up: Array Methods\n\nThe Task Manager you develop for this assignment requires you to use a number of methods of the JavaScript `Array` class. You should review those (lesson on [javascript.info](https://javascript.info/array-methods) & handbook on [FreeCodeCamp](https://www.freecodecamp.org/news/the-javascript-array-handbook/)). Open the `03-task-manager/optionalArrayMethodsReviewExtraAssignment.js` file. Instructions are inside the file, with examples. You can optionally implement the challenges required; this is recommended!\n\n### Task Manager with Mongo Database\n\nIn this lesson, you will\n\n* Set up a free Mongo Cloud account, and connect to a Mongo NoSQL database\n* Perform CRUD operations on that database\n* Only work on the back end. This means that to test your work, you must use Postman.\n\n## Warning: Skip download\n\nThe instructor suggests that you download code via a link on johnsmilga.com.  \n**Don’t do this.**\n\nJust continue to work on the same git repository you initially forked and downloaded for this course, which is `node-express-course`. You do not need to move directories from this git repository.\n\nCreate a new git branch called `week5`. **This should be created when the week4 branch is active, so that your work adds on to the work of the week4 branch.**\n\nThis week’s work is to be created in the `03-task-manager/starter` directory. Note that answers, if you get stuck, are in the `03-task-manager/final` directory, but try not to refer to that. Once you have changed directories to the `03-task-manager/starter` directory, you do an `npm install`. This loads the Node modules you will need for the assignment.\n\n## ⚠️ **Warning: Be Careful of Your Mongo Password!** ⚠️\n\nThe instructor pastes the Mongo database URI into the code. It includes a password. You may do the same to make sure it works. However, in general, you would _**NEVER**_ put a password or API key into your code because, when you push it to Github, it becomes public and anyone can access your data. There are hackers with Github scrapers that go looking for just such an exposure. A little later in the lesson, the instructor moves the Mongo URI into a `.env` file. This is where it should be kept.\n\nYou will notice a `.gitignore` file in the `03-task-manager/starter` directory. That contains lines for `/node_modules` and `.env`, which are the files you _do not_ want in Github. The `.gitignore` file is very important! **Do not git add, git commit, or git push your code while the Mongo URI is included in the code.** Be sure it is _**completely removed**_ from the code, not just commented out! If you make a mistake and git commit your code with a password in it, the ONLY recovery is to change the password. This is because git keeps every old version of your code!\n\nIn the future, you would create the `.env` file at the start of any project, and you would make sure that the `.gitignore` file includes `.env`, before putting any secrets like the Mongo password into the `.env`. You would never put such secrets in your code, even temporarily.\n\n## Additional Assignment\n\nWithin the starter directory, create a file `quizAnswers.txt`. Put answers to the following questions in it.\n\n1. Quickly explain how middleware is used in an Express application.\n2. What does CRUD stand for?\n3. You are careful to store your sensitive information in a .env file.  \n   1. How do you get your app to access the information in the .env file?  \n   2. How do you protect the contents of the .env file so that it is not stored in your Github repository?",
            "codeExample": "",
            "_id": "68f27f4a71abd9d6b34f6a60"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Lesson 5",
          "content": "Watch the “CodingAddict – Build 4 Node/Express Projects” video **[here](https://www.youtube.com/watch?v=rltfdjcXjmk)**. This lesson is on the first 1:28:45 of the video; next session’s lesson 6 will start with the section on validation.\n\nIn this lesson and in several that follow, **you duplicate the work of the instructor**, testing as you go with Postman. Since you will be building and testing as you watch, read through the Coding Assignment section below _**before**_ starting the video.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4a71abd9d6b34f6a5f"
        }
      ]
    },
    {
      "id": "68f27f4a71abd9d6b34f6a62",
      "lessonNumber": 6,
      "title": "Lesson 6",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 6",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "Create a new git branch called `week6`. **This should be created when the `week5` branch is active, so that it adds to week 5’s work.** If you’ve made any changes to the `week5` branch due to reviews on your PR, make sure to update your `week6` branch by following the instructions from [Lesson 4](./ctd-node-lesson-4.md) Continue to work in the `node-express-course/03-task-manager/starter` directory. You duplicate the work of the instructor in the video.\n\n### Additional Assignment\n\nCreate a file in the starter directory called `QuizAnswers2.txt`. Put answers to the following questions in it.\n\n1. In this lesson, you created a middleware function called `asyncWrapper`. Why?\n2. Suppose that you want to make sure that both a status code and an error message are sent back to the user when they request the URL for a task that does not exist. Assume that you’ve created a `CustomAPIError` class and an error handler that references that class. Complete the code:  \n```javascript  \nconst getTask = asyncWrapper(async (req, res, next) => {  \n  const { id: taskID } = req.params;  \n  const task = await Task.findOne({ _id: taskID });  \n  if (!task) {  \n    // your code here  \n  }  \n  res.status(200).json({ task });  \n});  \n```\n\nAs you will see in the lessons that follow, you do not have to always create the `asyncWrapper` middleware, because you can instead use an NPM package called `express-async-errors` that provides the same capability.",
            "codeExample": "",
            "_id": "68f27f4a71abd9d6b34f6a64"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Lesson 6",
          "content": "This week begins at 1:29 of **[this video](https://www.youtube.com/watch?v=rltfdjcXjmk&t=5280s)**, and continues until the end of the task manager project, at 3:07:18 of the video.\n\nIn this lesson you will continue to develop the Task Manager API, testing with Postman as you go. You will add:\n\n* Input Validation\n* Error Handling\n* Additional CRUD Operations",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4a71abd9d6b34f6a63"
        }
      ]
    },
    {
      "id": "68f27f4a71abd9d6b34f6a66",
      "lessonNumber": 7,
      "title": "## Concept: Thenables",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 7",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "Continue to work in the `node-express-course` repository. Create a new branch, `week7`. **This should be created when the `week6` branch is active, so that your new work adds to the previous work.** You will work in the directory `04-store-api/starter`. Once you have changed to that directory, be sure to run `npm install` to install the required Node modules. As in previous lessons, you will duplicate the work of the instructor, testing as you go with Postman.\n\n**This is a difficult lesson, so take your time with it**, stopping the video as needed so that you understand what is being done. Also, if you get stuck, the instructor’s solution is in the `04-store-api/final` directory. The idea is that one can search by any or all of these attributes: `featured`, `name`, `price`, `rating`, and `company`. For the numeric fields (`price` and `rating`), one can also specify that you are comparing the number given to see if its “greater than”, “less than”, or “equal to” that value. One can also specify a sort order (ascending or descending). Also, one can specify a `skip` and a `limit`, to facilitate pagination through the result. Be sure that you test each step with Postman. Almost all the work will be done in the `controllers/product.js` file. That file has two methods, `getAllProducts` and `getAllProductsStatic`. The `getAllProductsStatic` method is there for you to experiment with and won’t be directly reviewed.",
            "codeExample": "",
            "_id": "68f27f4a71abd9d6b34f6a6a"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Introduction",
          "content": "In this lesson, you parse the query parameters passed with the REST request, appending the search filters that result to your find operation. As in the previous lesson, you communicate with a MongoDB database. The lesson starts at 3:07:00 of **[this video](https://www.youtube.com/watch?v=rltfdjcXjmk&t=11220)**, and continues to 5:05:34.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4a71abd9d6b34f6a67"
        },
        {
          "subsectionOrder": 2,
          "title": "Concept: Thenables",
          "content": "One part of this assignment is a little confusing. You will see code like this:\n\n```javascript\nlet result = Product.find(queryObject);\n...\nresult = result.sort(sortList);\n...\nresult = result.select(fieldsList);\n...\nconst products = await result;\n```\n\nHow can this work? Isn’t `Product.find` asynchronous? The reason it works is that `Product.find` doesn’t return a `Promise`. It returns something that works like a Promise, but has extended capabilities. This is called a “then-able”. In this case, the thenable allows the search to be further defined. The `Product.find` call does not immediately send anything to the Mongo database, until `await` (or `.then`) is called on the thenable. Only then is the fully qualified search is sent to the database, and the Promise is resolved, and the products found by the search are returned.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4a71abd9d6b34f6a68"
        },
        {
          "subsectionOrder": 3,
          "title": "Concept: Regular Expressions",
          "content": "Regular expressions provide a general purpose string parsing syntax. A regular expression can be used to identify strings that match a pattern. Regular expressions can also be used to create modified strings by substituting character patterns. There are several tutorials on regular expressions on the web. Here is a selection of them:\n\n* [Regex Tutorial](https://regexlearn.com/)\n* [Game to help learn regex](http://play.inginf.units.it/#/)\n* [Interactive regex exercises](https://regexone.com/)\n\nIn this course, we will not teach the use of regular expressions, but you should be aware of their purpose. To complete your homework, you can just copy the regular expressions used by the instructor from their location in the final directory.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4a71abd9d6b34f6a69"
        }
      ]
    },
    {
      "id": "68f27f4b71abd9d6b34f6a6c",
      "lessonNumber": 8,
      "title": "## Concepts: Authentication with JWT Tokens",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 8",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "We want to give you an opportunity to get creative and to do your own work, so for this assignment, you should try creating your own Express applications. If you don’t feel comfortable doing this yet, you can just emulate the instructor in the video as before. For either assignment, please complete the section at the bottom of this page on how to automatically save the authentication token in Postman.\n\n### Preferred Coding Assignment\n\nYou continue to work in the `node-express-course` repository. For this lesson, you work in the `05-JWT-Basics` directory. Create a new branch, `week8`. **This branch should be created when the `week7` branch is active**. Create a folder called `preferred` inside the `05-JWT-Basics` directory. Inside that folder, create an Express application. You’ll need to do an `npm init` inside that folder (you can accept all the defaults), and you’ll need to `npm install` the `express`, `jsonwebtoken`, and `dotenv` packages. You also need to create a `.gitignore` file with `.env` and `/node_modules` as lines in that file. Follow best practices in organizing this application: you should have an `app.js` and then, in separate directories, your routes, middleware, and controllers. (You only need one file in each of these folders for this assignment.)\n\nYou’ll need to call two functions from the `jsonwebtoken` package. The functions are documented [here.](https://www.npmjs.com/package/jsonwebtoken) The functions you need are `jwt.sign` (to create the token) and `jwt.verify` (in your authentication middleware). Ideally you would use the asynchronous forms of these functions, with a callback for each, but if that sounds too complicated, just use the synchronous forms. If you use the synchronous calls, be sure that you do a `try/catch` for the `jwt.verify()`, as it will throw an error if the token isn’t valid.  In the video, there is a reference to a random key generator that no longer works.  It is important to have a very random key to generate the JWTs, because a hacker ever guessed or derived the key, the security of the application would be completely compromised.  You can use the key generator [here.](https://acte.ltd/utils/randomkeygen)\n\nThe application should have two routes, a `POST` for `/api/v1/logon`, and a `GET` for `/api/v1/hello`. The `POST` request takes a JSON body with two attributes, `\"name\"` and `\"password\"`. It returns a 200 (`OK`) return code and a JSON object with one attribute, a `\"token\"`, which is the JSON web token. You’ll need a secret (which is a long, hard-to-guess string) and a lifetime, which should be “24h”. These values should be read out of a `.env` file using the `dotenv` package. You should store the user’s name inside the token.\n\nYou will protect the `GET` request by a middleware authentication function. This checks the `Authorization` header. You get that by doing `req.header(\"Authorization\")`. This should be a string starting with `\"Bearer \"` (note the space after the word ‘Bearer’) and followed by a string of random characters. You take the random part of the string (using the `split()` function) and validate the token. If the token is not present or not valid, you return a 401 (unauthorized) status code and a JSON object that has one attribute, “message” with the value “unauthorized”. (You don’t call `next()` in this case, because we don’t want to proceed to the controller function.) If the token is present and valid, the middleware gets the user’s name from the token payload. Then it creates a hash with one key “name” and a value being the user’s name, and you save it in `req.user`. Then call `next()` to pass control to the controller for the GET request.\n\nThat controller should return a 200 response code and a JSON object that has one attribute, “message”, with some message to the user that includes the user’s name (from `req.user.name`).\n\nTest your application with Postman. What you test for the `POST` request should be straightforward. But if you try the GET request, you should get back “unauthorized”. To test a successful GET request, you have to configure the authorization for that request in Postman. First do the POST request. You’ll get back a token. Copy the token to the clipboard. Then go to the GET request and click on Authorization. Select Bearer and paste in the token. Save the request. Then send it. You should get back the message with your user’s name.\n\nOptionally, you could create a simple HTML and JavaScript front end for the application in a preferred/public directory. The front end would have a login form, and would make a fetch or axios request to the back end API to do the login, saving the resulting token in local storage. Then it would send another fetch or axios request to the back end, with a Bearer token in the authorization header, to get the hello message, displaying the result to the user. This is only a few lines of work, and you can look at the video instructor’s example.\n\n### Alternate Coding Assignment\n\nThis is only in case you aren’t confident that you can complete the preferred coding assignment. You continue to work in the `node-express-course` repository. For this lesson, you work in the `05-JWT-Basics/starter` directory. Create a new branch, `week8`. **This branch should be created when the `week7` branch is active**. Then run `npm install` to install the required node packages. Duplicate the steps that the instructor performs, testing with Postman as you go. There are two routes to test, a `POST` route to `/api/v1/login`, and a `GET` request, to `/api/v1/dashboard`. For the `GET` request, you have to configure the authorization for that request in Postman. First do the `POST` request and copy the token to the clipboard. Then go to the `GET` request and click on `Authorization`. Select `Bearer` and paste in the token value. Then save the request and try it.\n\n### Saving the Token Automatically in Postman\n\nThis is a little complicated, but you should learn to do it for use in future assignments. First click on New in the upper left, and select Environment. Set the title to JWT Basics. Then on the upper right, click on Environments and set it to JWT Basics, to make that environment active.\n\n![Walkthrough of Postman environment intialization](https://storage.googleapis.com/ctd-course-bucket/courses/68f27f4071abd9d6b34f69f9/images/67a6b66e-c2d1-44f7-b10d-186bff54b6a9.gif)  \n_(right-click and open image in a new tab to see it a little larger)_\n\nNow open up the POST request for logon. Click on tests. Then enter the following code:\n\n```javascript\nconst jsonData = pm.response.json();\npm.environment.set(\"token\", jsonData.token);\n```\n\n![Screenshot of setting a variable from the Postman environment](https://storage.googleapis.com/ctd-course-bucket/courses/68f27f4071abd9d6b34f69f9/images/1358621e-5ed8-4b74-a6a3-090a009d74f8.png)\n\nThis code reads the `\"token\"` attribute from the response JSON and saves it in the “token” environment variable that you created earlier. Then save and run the logon request. There is an icon on the upper right with an eye on it. This gives you a look at the environment. You should see the token in the environment.\n\nNext, open the `GET` request authorization again. Click on authorization, Bearer. This time, for the token value, put `{{token}}`. This uses the token variable from the environment. Then save and run the request. It should work as before.",
            "codeExample": "",
            "_id": "68f27f4b71abd9d6b34f6a71"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Concepts: Authentication with JWT Tokens",
          "content": "When you deploy a web application that allows users to create entries in a database, you typically need to protect that application with some form of authentication. Each user registers with the application, specifying a user identifier and a password. This information is stored by the application, typically in a database. If the application stores this information in MongoDB, you will have a User model. The model stores the user ID, a hash of the password, and perhaps other information. **The password itself is never stored, because that would make the application a risky repository of user passwords.** Instead, a **cryptographic hash** of the password is stored, and this information allows the user password to be validated at logon time, without needing to actually store the password itself.\n\nWhen the user logs in, the front end of the application needs to store a credential for use in subsequent requests — otherwise the user would have to log in for every protected request. One type of credential that is often used for REST requests is a JSON Web Token (JWT). The token is cryptographically signed by the server, using a secret string that’s only known by the server, so it can’t be counterfeited. The token contains information about which user is logged in. The token is not human-readable, but it is not encrypted either, so you should never put sensitive information in it, especially not the password or password hash. When the user is registered in MongoDB, a unique ID is created, just as it is for every MongoDB entry. This ID is typically stored in the token.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a6d"
        },
        {
          "subsectionOrder": 2,
          "title": "A Comment On Security",
          "content": "The way the instructor uses the JWT is as follows: (1) The user logs in with id and password, and the JWT is returned in the body of the response. (2) The web front end stores the JWT in local storage. (3) In subsequent requests, the JWT is inserted by the front end as a Bearer token in the `Authorization` header, so that it can be validated and so that the back end knows which user is making the request. You can see an example of this in the public directory for this assignment. This is a common practice — and a **very bad one!** You should never store sensitive information in the browser’s local storage. This is because, especially in large and complicated web front ends, it is common to introduce a vulnerability to a security attack called cross site scripting (XSS). If the application has an XSS vulnerability anywhere, the attacker can capture the token from local storage, and can then reuse that token to impersonate the user, doing any operations the user can do.\n\nSo, if you can’t put the token in local storage, how can you keep it on the browser side to maintain a logged on user session? The way this is done is for the server to set an HTTP-only cookie for the user session. The cookie is stored by the browser, but it is inaccessible to JavaScript in the browser session. When the front end sends a `fetch()` request to get data, the `fetch()` is performed with either `credentials: 'include'` or `credentials: 'same-origin'`. This causes the cookie to be sent back to the back end for validation.\n\nBut, there is one more hitch. When a cookie is used, an attacker can then do cross site request forgery (CSRF), another security attack where the attacker leverages the fact that the cookie is automatically sent with a form post. So, one must add protections for CSRF, such as that provided by [this package](https://www.npmjs.com/package/host-csrf). we’ll use that package later in the course.\n\nFor the next few assignments, you will follow the approach the instructor recommends — but do not do it in a production application! Actually, the approach where the caller saves the JWT for use in the authorization header is fine, but only when one server is talking to another. In that case, the calling server can store the JWT without using browser local storage.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a6e"
        },
        {
          "subsectionOrder": 3,
          "title": "Protecting Routes",
          "content": "To protect routes in your Express application, you create authentication middleware, which runs before the route handler for each protected request. The authentication middleware checks that the token is present with the HTTP request, typically as the Bearer token in the `Authorization` header. Then it validates the token cryptographically, making sure the signature matches the secret. Then, it stores the user ID and perhaps other information about that user in the `req.user` property as a hash/object, so that it can be used by the controller functions handling each request. For example, this allows you to write a controller function that returns only the information that the logged on user is authorized to see.\n\nSome routes are not protected by the authentication middleware, including in particular the logon route and registration routes and any other pages we want all users to be able to see whether or not they are logged in.\n\nCryptography is complicated, and you shouldn’t try to do your own. In this assignment, we use the `jsonwebtoken` [npm module](https://www.npmjs.com/package/jsonwebtoken) to create the tokens (at logon time) and to validate tokens (in the middleware of authenticated routes). For this lesson, we won’t store the user information, which means that the user is not registered and the password is not validated. (We’ll do that in a later lesson.) Instead, the user enters an ID and password and a JWT token is created. Then the token is used to access the protected route.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a6f"
        },
        {
          "subsectionOrder": 4,
          "title": "Concepts: Error Handling",
          "content": "The instructor shows how to throw errors, such as authentication errors, and how to handle them in an error handler. The elements of error handling are as follows:\n\n* The `express-async-errors` package is installed. It will catch errors thrown in your controllers and send them on to the process error handler. This prevents you from having to write `try...catch` blocks in all of your controllers.\n* A `StatusError` class that can be instantiated when an error occurs. This class should extend the built-in `Error` class. It should have a constructor that takes two parameters, (1) the error message and (2) a number that is the HTTP status code.\n* Error handling middleware. This is called as a result of an `app.use()` statement that appears after all of your routes. It must be declared with four parameters, which are named `err`, `req`, `res`, and `next`.\n\nThe error handler has to return something to the caller, as otherwise the caller would just hang indefinitely waiting on the HTTP response. So it returns an appropriate HTTP result code, along with a descriptive error message. As this is an API, the error message is returned as JSON. If there is an error in your code, the error handler is invoked. Some errors are expected, and in this case the error handler can return a descriptive error message and an appropriate HTTP result code to the caller. For example, you might have a validation error when creating or updating an entry. In your error handler, you need to parse the validation error to get a useful error message, such as how one or several attributes failed the validation. Authentication errors are also expected, for example when the user enters an invalid email or password when logging in. “Cast” errors can occur if the request includes an ID that is not a valid Mongo object ID, so this is an expected error and you can return a 404\\. Please look at the instructor’s code to see how these cases are handled.\n\nBut some errors are not expected — that is, if your code is working right, they should never occur. An example is a variable reference error caused by a code bug. For these, it is not a good idea to give the original error message back to the user, as it is not friendly and it discloses code internals. So you return a message such as “A server error occurred.” with a 500 result code, and you also do a console log of such errors, so that you can find the bug. The instructor does not do this logging, but he should.\n\nThe `StatusError` class could look like this:\n\n```javascript\nclass StatusError extends Error {\n  constructor(message, resultCode) {\n    super(message);\n    this.statusCode = resultCode;\n  }\n}\n```\n\nUsing this class, if your authentication middleware finds that the JWT token is missing or invalid, you can just throw the error as follows:\n\n```javascript\nthrow new StatusError(\n  \"The request was not authenticated\",\n  StatusCodes.UNAUTHORIZED\n);\n```\n\nThen you add appropriate code to the error handler to handle this case, sending back the status code and an appropriate JSON message to the caller.\n\n## Continuing with the Video\n\nThe video instruction for this lesson starts at 5:05:30 of **[this video](https://youtu.be/rltfdjcXjmk?t=18325)** and continues to 6:28:35.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a70"
        }
      ]
    },
    {
      "id": "68f27f4b71abd9d6b34f6a73",
      "lessonNumber": 9,
      "title": "# Thinking About Your Final Project",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 9",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "There is a **new repository** for this lesson. It is [**here**](https://github.com/Code-the-Dream-School/06-jobs-api)[.](https://github.com/Code-the-Dream-School/06-jobs-api) This is because you will eventually deploy the repository to a cloud service so that it runs on the Internet. The instructor has you do the work in the `node-express-course/06-jobs-api/starter` directory, and then copy that entire directory tree to a folder outside of the `node-express-course` folder, and then do a `git init`. That is complicated and messy. So we have this new repository instead. It is just a copy of the starter directory, but in its own repository. So, fork this repository and then clone your fork. For a reminder on how to fork a Github repo, you can refer to the instructions at the top of the [Lesson 1 Assignment.](./ctd-node-lesson1.md)\n\n### **Warning!**\n\nWhen you clone, make sure you are not inside the`node-express-course` folder, so that you keep this repository separate.\n\nYou will do your work in this new `06-jobs-api` repository directory. If you get stuck, answers are in the old repository, in the `node-express-course/06-jobs-api/final` directory, but please try to do your own work. Before you start this lesson, you create the `week9` git branch.\n\n### **Warning!**\n\n**_Do not_** do the copy of the starter directory that is described by the instructor.\n\n**_Do not_** do the `git init`.\n\nYou can choose to just repeat the work that the instructor shows, but it is better if you invent a model for a new kind of record you want to create instead of the Job model, as described above in the “Thinking About Your Final Project” section.\n\n**Be sure you test each step with Postman, creating a Postman collection of tests just like the instructor is doing.** This Postman collection of tests is used not only to test the API as it runs on your machine, but also, in Lesson 10, to test the application as deployed to Render.com. (We deploy to Render.com instead of to Heroku, as Heroku no longer allows applications to be deployed for free.)",
            "codeExample": "",
            "_id": "68f27f4b71abd9d6b34f6a78"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Thinking About Your Final Project",
          "content": "In this lesson, as in the previous one, you can choose to implement some content different from what the instructor shows. The instructor shows CRUD operations for job records, and uses a Job model. However, you can choose to store objects of a different kind instead of job records. Try to imagine something for an application you’d like to invent! This work could then comprise the beginning of your final project. Look at the final project rubric **[here](https://learn.codethedream.org/node-express-final-project-latest/)** to see what is required. (Bear in mind, though, that there are two ways to go in the final project — either using a front end and back end, or using server side rendering, which we haven’t covered yet.)\n\nIf you do implement a model different from the Job model, it should still have a `createdBy` attribute, which is a reference to a `User` record, to associate each entry with a particular user, and the `createdBy` attribute should be of type `mongoose.Types.ObjectId`. This is for access control: A particular user can do CRUD operations only on their own records. Your model should also have an entry that is an `enum` type. You use an enum when an attribute can take only a small set of values, like “vanilla”, “chocolate”, and “strawberry” for ice cream flavors. See the instructor’s work for the `Job` model in the final directory for an example, both of how to do the `createdBy` attribute and how to do an enum. You are encouraged to use a variety of data types in your model such as numbers, strings, and dates.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a74"
        },
        {
          "subsectionOrder": 2,
          "title": "Concepts: Authentication with JWT Tokens",
          "content": "In this lesson as in the previous one, you use JSON web tokens (JWTs) for authenticating the user. But, in this case, you do store user records in MongoDB, so you have a User model. You store the user’s name, email, and hashed password in the database. **We never store passwords in plain text**. Instead, they are cryptographically hashed so that even if the database is compromised, the passwords are not. The cryptography for the password comes from the `bcryptjs` npm package. The hashing is performed in a middleware routine that is added to the `User` model, which is a pre-routine for the save operation (meaning that it will run before saving data to the database for any `.save()` call). You also add instance methods to the `User` model for generating the `JWT` and for validating the user password. When you do so, you use the `function` keyword, not the arrow function syntax, so that the function is associated with the `this` variable correctly. In this case `this` will be the user instance that’s being operated on. You also set timestamps on your entries, just as the instructor does.\n\nAs in the previous lesson, you use authentication middleware to protect routes.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a75"
        },
        {
          "subsectionOrder": 3,
          "title": "Concepts: Access Control for Entries",
          "content": "The purpose of `createdBy` is to limit access to certain entries. For each of your CRUD operations, you use the ID of the User record for the logged on user. Your authentication middleware stores this in `req.user` when the JWT token is validated. When creating a `Job` entry (or an entry of the new model you create instead of using Job) you store the user’s ID in the createdBy attribute. When retrieving the Job entries, or a single Job entry, or doing an update or delete of a Job entry, you include the user’s ID to filter your Mongoose operation, to make sure that a user can’t see or change or delete another user’s records.\n\nFor this lesson, you create only an API. Although the instructor mentions a front end, he does not provide one, so each of your routes must be tested using Postman.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a76"
        },
        {
          "subsectionOrder": 4,
          "title": "Continuing with the Video",
          "content": "This lesson runs from 6:28:35 to 8:20:35 of **[this video](https://youtu.be/rltfdjcXjmk?t=23306)**. **Read the Coding Assignment Instructions before watching the video, so that you know how your assignment will differ from the video instructions.**\n\nAs with previous lessons, you duplicate the work that the instructor shows, except that instead of creating a Job model, you can choose to create a model of your own choosing. (You can use the `Job` model the instructor uses if you prefer, but it would have to be extended to make a final project.)",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a77"
        }
      ]
    },
    {
      "id": "68f27f4b71abd9d6b34f6a7a",
      "lessonNumber": 10,
      "title": "## Concepts: Internet Deployment",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 10",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "Complete and test all CRUD operations for your model (or the `Jobs` model). Be sure that each operation uses the ID of the user, so that you have good access control.\n\n**Test each step with Postman, creating a Postman collection of tests just like the instructor is doing.**\n\n### Deploying to Render.com\n\nYou deploy your application once you have your assignment completed and working, and once you have pushed your `week10` branch to Github.\n\nTo deploy to Render.com, follow these steps:\n\n1. Specify the version of Node that Render is to use. One way is to create a `.node-version` file in the root of your project repository, specifying the same version of node as you are running on your machine. On my machine, when I type `node -v`, I get back v16.19.0 . So I would create a `.node-version` file with the single line: `16.19.0`\n2. Create a [Render.com](https://render.com/) account. You do not need to install anything on your workstation for Render deployment. You do not need to enter any credit card information.\n3. From your Render.com dashboard, click on the New button in the upper right. Select Web Service. You will then be prompted to connect a repository. Scroll down to the entry field that says “public git repository”, and enter the URL of your 06-jobs-api repository. Then press continue.\n4. The next page prompts you for the name of the service. This becomes the first part of the URL for your application. You need to give it a unique name that no one else is using, maybe something like `jobs-api-<your name>`.\n5. Scroll down to the entry field for branch. Put in `week10`.\n6. Scroll down until you see the “advanced” button. Click on that. You then click on Add Environment Variable. You need to add an environment variable for each of the values in your .env file: the Mongo URI, the JWT key, and so on.\n7. Scroll to the bottom and click on Create Web Service. Render.com then builds the application for deployment. The process takes a while. Once the process completes, you see a link in the upper right for your new web service. The URL will be something like `https://jobs-api-<your name>.onrender.com`.\n8. Copy that URL and put it into your Postman tests for the assignment. Then test with Postman. Your application is live!\n\n<video controls=\"\" title=\"Deploying backend on Render.com\" src=\"./images/lesson10-deploying-on-render.mp4\"></video>\n\n### Swagger / OpenAPI documentation\n\nThe section of the video from 9:34:30 to the end discusses setting up a Swagger configuration. When you have an API, you need to document it so that implementers of applications that call the API (like the frontend) know what the available endpoints and operations are. Swagger is the best way to do that. It also creates a graphical user interface so that one can call the APIs directly from the UI. You should watch this section so that you understand how a Swagger configuration may be created and what functions it provides. However, this section of the video gets a bit complicated, so you are not required to implement Swagger for your application, but it’s a great idea to watch this section and familiarize yourself with the concept of Swagger. If possible, try to implement it as a bonus task this week.",
            "codeExample": "",
            "_id": "68f27f4b71abd9d6b34f6a7d"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Introduction",
          "content": "In this lesson, you complete implementation of the CRUD operations for the API, using either the `Job` model as the instructor does, or the model you invented in the last lesson. You test with Postman as you go. Your Postman configuration should have environment variables for the URL and, as the instructor explains, the accessToken. You will improve the error handling to return meaningful error messages to the user when Mongoose validation errors occur. You then add security protection for the application so that it can be deployed on the Internet. The security configuration uses the following node packages:\n\n* [helmet](https://www.npmjs.com/package/helmet) for setting various HTTP headers to protect against well-known vulnerabilities\n* [cors](https://www.npmjs.com/package/cors) for enabling cross-origin resource sharing\n* [xss-clean](https://www.npmjs.com/package/xss-clean) for preventing cross-site scripting attacks. Note that this package is now deprecated. We can still use it for this assignment, but we will need to find a replacement for it in the future.\n* [express-rate-limit](https://www.npmjs.com/package/express-rate-limit) for limiting the number of requests from a single IP address. This is to prevent denial of service attacks.\n\nThese packages must be used whenever you deploy an application publicly, to minimize the chance of a security exposure. For your class final project, you will use these same packages, because you will deploy your final project on the Internet, and you want it to be secure.\n\nAs for the previous lesson, you may duplicate the work that the instructor shows, or if in the last lesson you invented your own model to use instead of the `Job` model, you instead implement CRUD operations for your model. You continue to put your work in the new `06-jobs-api` **repository** that you forked and cloned last session. If you get stuck, answers are in the `node-express -course/06-jobs-api/final` directory, and it’s certainly a good idea to read the instructors code, but please try to do your own work. Before you start this lesson, you create the `week10` git branch, **which should be created when the `week9` git branch is active**. This lesson runs from 8:20:35 to 9:34:30 of **[this video](https://youtu.be/rltfdjcXjmk?t=30036)**.\n\nThe instructor shows how to deploy to Heroku. However, since this video was made, Heroku has announced that they are ending free access for deploying web applications. **Therefore, do not install the Heroku CLI, and do not deploy to Heroku.** Instead, you deploy your application to Render.com. Instructions for deploying to Render.com are found in the [Assignment section](/node-express/lesson10-a1).",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a7b"
        },
        {
          "subsectionOrder": 2,
          "title": "Concepts: Internet Deployment",
          "content": "When you deploy to the Internet, you need to be confident that your application is secure. In your case, the risk is very small, because you aren’t storing or retrieving sensitive information. This is fortunate, because security is hard — very hard. The packages the instructor specifies are good starting points.\n\nCORS stands for cross-origin resource sharing, and it is what allows one web application to call another, subject to configuration limits. The front end we will build in lesson 12 will run from the same origin (the origin is the base URL) as the back end, so we don’t really need CORS. But frequently you will build a front end, using React or some other framework, that resides on a different origin from the back end. Without CORS, the REST requests to the back end will fail. So, depending on how you build your final project, you may need CORS. CORS enables cross-origin access, but it can and should be configured to limit it as well, to avoid attacks on application security. The default configuration is not very secure, because it permits access from any origin whatsoever. You can check the documentation for the npm CORS package to see how it should be configured.\n\nThe xss-clean package is to avert an attack called cross site scripting. This occurs when an attacker is able to insert some JavaScript into your application and have your application run that script, potentially getting access to resources managed by the application. This can happen when a script is inserted into a URL that calls the application, or into a REST request, or into an HTML form. The xss-clean package strips those scripts out.\n\nThe helmet package provides additional protection against cross site scripting. It sets headers on your HTML pages to limit what script the pages will load. Helmet can get a bit complicated to configure for a front end, particularly if the front end uses resources to style the application such as Bootstrap.\n\nThe express-rate-limit package limits the number of requests that can be issued per minute from a given client, so that attackers can’t cause application problems by brute force.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a7c"
        }
      ]
    },
    {
      "id": "68f27f4b71abd9d6b34f6a7f",
      "lessonNumber": 11,
      "title": "Lesson 11",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 11",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "Continue working in the `06-jobs-api` repository that you used for lessons 9 and 10\\. Before you start, create a new branch as usual, with a branch name of `week12`. (Week 11 was a catch-up week, so you create the `week12` branch when the `week10` branch is active.)\n\nCreate a directory called `public`. This is for the HTML and JavaScript files for the front end. The HTML code you will use is below. Put that in the `public` directory with a file name of `index.html`. (**Reminder:** You will have to change the form, which below is for a job, to match your data model).\n\nThis lesson does not involve the creation of any new Node or Express functions. It is all client-side HTML and JavaScript.\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Jobs List</title>\n  </head>\n\n  <body>\n    <h1>Jobs List</h1>\n    <hr />\n    <p id=\"message\"></p>\n    <hr />\n    <div id=\"logon-register\" style=\"display:none;\">\n      <button type=\"button\" id=\"logon\">logon</button>\n      <button type=\"button\" id=\"register\">register</button>\n    </div>\n    <div id=\"logon-div\" style=\"display:none;\">\n      <form>\n        <div>\n          <label for=\"email\">email:</label>\n          <input type=\"email\" id=\"email\" />\n        </div>\n        <div>\n          <label for=\"password\">password:</label>\n          <input type=\"password\" id=\"password\" />\n        </div>\n        <button type=\"button\" id=\"logon-button\">logon</button>\n        <button type=\"button\" id=\"logon-cancel\">cancel</button>\n      </form>\n    </div>\n    <div id=\"register-div\" style=\"display:none;\">\n      <form>\n        <div>\n          <label for=\"name\">name:</label>\n          <input type=\"text\" id=\"name\" />\n        </div>\n        <div>\n          <label for=\"email1\">email:</label>\n          <input type=\"email\" id=\"email1\" />\n        </div>\n        <div>\n          <label for=\"password1\">password:</label>\n          <input type=\"password\" id=\"password1\" />\n        </div>\n        <div>\n          <label for=\"password2\">verify password:</label>\n          <input type=\"password\" id=\"password2\" />\n        </div>\n        <button type=\"button\" id=\"register-button\">register</button>\n        <button type=\"button\" id=\"register-cancel\">cancel</button>\n      </form>\n    </div>\n    <div id=\"jobs\" style=\"display:none;\">\n      <p id=\"jobs-message\"></p>\n      <table id=\"jobs-table\">\n        <tr id=\"jobs-table-header\">\n          <th>Company</th>\n          <th>Position</th>\n          <th>Status</th>\n          <th colspan=\"2\"></th>\n        </tr>\n      </table>\n      <button type=\"button\" id=\"add-job\">add job</button>\n      <button type=\"button\" id=\"logoff\">log off</button>\n    </div>\n    <div id=\"edit-job\" style=\"display:none;\">\n      <form>\n        <div>\n          <label for=\"company\">company:</label>\n          <input type=\"text\" id=\"company\" />\n        </div>\n        <div>\n          <label for=\"position\">position:</label>\n          <input type=\"text\" id=\"position\" />\n        </div>\n        <div>\n          <label for=\"status\">status:</label>\n          <select id=\"status\">\n            <option value=\"pending\">pending</option>\n            <option value=\"interview\">interview</option>\n            <option value=\"declined\">declined</option>\n          </select>\n        </div>\n        <button type=\"button\" id=\"adding-job\">add</button>\n        <button type=\"button\" id=\"edit-cancel\">cancel</button>\n      </form>\n    </div>\n  </body>\n</html>\n```\n\nThis front end uses a single-page style. There are multiple views in the page, in different DIV elements, but which of these is visible is controlled by the JavaScript you write.\n\nEdit `app.js`. Comment out the following lines:\n\n```javascript\napp.get(\"/\", (req, res) => {\n  res.send('<h1>Jobs API</h1><a href=\"/api-docs\">Documentation</a>');\n});\n```\n\nAdd the following line below these commented out lines:\n\n```javascript\napp.use(express.static(\"public\"));\n```\n\nStart the server and go to `localhost:3000` in your browser. You see the page, but it does not do anything. This is because there is no JavaScript to go with it. You create that now. This is the JavaScript for the front end. **Front end JavaScript does not run in Node. Instead, it is delivered to the browser and runs in the browser context, with full access to the `document`, `window`, and `DOM` variables.**\n\nThere are various divs to be manipulated by this JavaScript. (Again, you have to change this code to match your data model.) The keep the code organized, we will separate them into various modules (files). There is one module, index.js, to initialize window handling. All the other modules can be imported from there. There are five divs, only one of which will show at a time:\n\n* one to select logon or register,\n* one to do logon,\n* one to do register,\n* one to display the jobs,\n* and one to add or edit a job.\n\nFor each of these divs, there is a separate module controlling its operation.\n\nTo begin, add the following line to index.html, right above the close of the body tag:\n\n```\n<script src=\"./index.js\" type=\"module\"></script>\n```\n\nThese modules call one another using the exports that each provides. For this to work, you must declare it as type `module`. Create `index.js` in the public directory. The `index.js` module should read as follows:\n\n```javascript\nlet activeDiv = null;\nexport const setDiv = (newDiv) => {\n  if (newDiv != activeDiv) {\n    if (activeDiv) {\n      activeDiv.style.display = \"none\";\n    }\n    newDiv.style.display = \"block\";\n    activeDiv = newDiv;\n  }\n};\n\nexport let inputEnabled = true;\nexport const enableInput = (state) => {\n  inputEnabled = state;\n};\n\nexport let token = null;\nexport const setToken = (value) => {\n  token = value;\n  if (value) {\n    localStorage.setItem(\"token\", value);\n  } else {\n    localStorage.removeItem(\"token\");\n  }\n};\n\nexport let message = null;\n\nimport { showJobs, handleJobs } from \"./jobs.js\";\nimport { showLoginRegister, handleLoginRegister } from \"./loginRegister.js\";\nimport { handleLogin } from \"./login.js\";\nimport { handleAddEdit } from \"./addEdit.js\";\nimport { handleRegister } from \"./register.js\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  token = localStorage.getItem(\"token\");\n  message = document.getElementById(\"message\");\n  handleLoginRegister();\n  handleLogin();\n  handleJobs();\n  handleRegister();\n  handleAddEdit();\n  if (token) {\n    showJobs();\n  } else {\n    showLoginRegister();\n  }\n});\n```\n\nRemember that this code is running in the browser, and not in Node. That means you must use `import` and not `require`.\n\nWe need to keep track of the active div so that we know which one to disable when switching between them, and that is stored in the variable `activeDiv`. We don’t need to export that variable since it’s only used here in the index script by the `setDiv` function. We export a function that sets the active div, making it visible and hiding the previous active div.\n\nWe also have to have a means of enabling or disabling input. This is because we will use asynchronous functions, and the application can get confused if more input comes in while the previous requests are in progress.\n\nWe also have to keep track of whether the user is logged in. We do that in a `token` variable that we store in the browser’s local storage (although this creates security risks as previously described.) When local storage is used, the user remains logged in even if the page is refreshed. If the function is called with a `null` token, then we _remove_ the token from local storage instead.\n\nWhen the user takes actions we may want to display a message on the page. We store the value of that message here in the index script in the `message` variable, so that it can easily be updated by any of the other modules.\n\nOnce the DOM is loaded, we load the token (if it exists already) from the browser’s local storage and initialize the handlers for each of the divs.\n\nThen, if the user is logged in, we display the list of jobs. If the user is not logged in, we display the initial panel with a button for logon and a button for register. Note that we need to provide and to export functions to set the enabled flag and the token. This is because one can’t write directly to variables from other modules. Once a variable is `import`ed in a module, it is treated as a `const` variable in that module, so you cannot reassign values to that variable directly.\n\nYou will need to create `loginRegister.js`, `register.js`, `login.js`, `jobs.js`, and `addEdit.js` files, all in the public directory.\n\nThe `loginRegister.js` module is as follows:\n\n```javascript\nimport { inputEnabled, setDiv } from \"./index.js\";\nimport { showLogin } from \"./login.js\";\nimport { showRegister } from \"./register.js\";\n\nlet loginRegisterDiv = null;\n\nexport const handleLoginRegister = () => {\n  loginRegisterDiv = document.getElementById(\"logon-register\");\n  const login = document.getElementById(\"logon\");\n  const register = document.getElementById(\"register\");\n\n  loginRegisterDiv.addEventListener(\"click\", (e) => {\n    if (inputEnabled && e.target.nodeName === \"BUTTON\") {\n      if (e.target === login) {\n        showLogin();\n      } else if (e.target === register) {\n        showRegister();\n      }\n    }\n  });\n};\n\nexport const showLoginRegister = () => {\n  setDiv(loginRegisterDiv);\n};\n```\n\nEach of the div handling modules follow this pattern. Required imports (used when one div handler calls another) are resolved up front. Then, within the handler function, the div and its controls are defined. Also, within the handler function, an event handler is declared to handle mouse clicks within the div.\n\nA separate function handles display of the div. (React works in similar fashion, if you know that framework — but this lesson does not use React.)\n\nThe `register.js` module is as follows:\n\n```javascript\nimport {\n  inputEnabled,\n  setDiv,\n  message,\n  token,\n  enableInput,\n  setToken,\n} from \"./index.js\";\nimport { showLoginRegister } from \"./loginRegister.js\";\nimport { showJobs } from \"./jobs.js\";\n\nlet registerDiv = null;\nlet name = null;\nlet email1 = null;\nlet password1 = null;\nlet password2 = null;\n\nexport const handleRegister = () => {\n  registerDiv = document.getElementById(\"register-div\");\n  name = document.getElementById(\"name\");\n  email1 = document.getElementById(\"email1\");\n  password1 = document.getElementById(\"password1\");\n  password2 = document.getElementById(\"password2\");\n  const registerButton = document.getElementById(\"register-button\");\n  const registerCancel = document.getElementById(\"register-cancel\");\n\n  registerDiv.addEventListener(\"click\", (e) => {\n    if (inputEnabled && e.target.nodeName === \"BUTTON\") {\n      if (e.target === registerButton) {\n        showJobs();\n      } else if (e.target === registerCancel) {\n        showLoginRegister();\n      }\n    }\n  });\n};\n\nexport const showRegister = () => {\n  email1.value = null;\n  password1.value = null;\n  password2.value = null;\n  setDiv(registerDiv);\n};\n```\n\nThe `login.js` module is as follows:\n\n```javascript\nimport {\n  inputEnabled,\n  setDiv,\n  token,\n  message,\n  enableInput,\n  setToken,\n} from \"./index.js\";\nimport { showLoginRegister } from \"./loginRegister.js\";\nimport { showJobs } from \"./jobs.js\";\n\nlet loginDiv = null;\nlet email = null;\nlet password = null;\n\nexport const handleLogin = () => {\n  loginDiv = document.getElementById(\"logon-div\");\n  email = document.getElementById(\"email\");\n  password = document.getElementById(\"password\");\n  const logonButton = document.getElementById(\"logon-button\");\n  const logonCancel = document.getElementById(\"logon-cancel\");\n\n  loginDiv.addEventListener(\"click\", (e) => {\n    if (inputEnabled && e.target.nodeName === \"BUTTON\") {\n      if (e.target === logonButton) {\n        showJobs();\n      } else if (e.target === logonCancel) {\n        showLoginRegister();\n      }\n    }\n  });\n};\n\nexport const showLogin = () => {\n  email.value = null;\n  password.value = null;\n  setDiv(loginDiv);\n};\n```\n\nThe `jobs.js` module is as follows:\n\n```javascript\nimport {\n  inputEnabled,\n  setDiv,\n  message,\n  setToken,\n  token,\n  enableInput,\n} from \"./index.js\";\nimport { showLoginRegister } from \"./loginRegister.js\";\nimport { showAddEdit } from \"./addEdit.js\";\n\nlet jobsDiv = null;\nlet jobsTable = null;\nlet jobsTableHeader = null;\n\nexport const handleJobs = () => {\n  jobsDiv = document.getElementById(\"jobs\");\n  const logoff = document.getElementById(\"logoff\");\n  const addJob = document.getElementById(\"add-job\");\n  jobsTable = document.getElementById(\"jobs-table\");\n  jobsTableHeader = document.getElementById(\"jobs-table-header\");\n\n  jobsDiv.addEventListener(\"click\", (e) => {\n    if (inputEnabled && e.target.nodeName === \"BUTTON\") {\n      if (e.target === addJob) {\n        showAddEdit(null);\n      } else if (e.target === logoff) {\n        showLoginRegister();\n      }\n    }\n  });\n};\n\nexport const showJobs = async () => {\n  setDiv(jobsDiv);\n};\n```\n\nThe `addEdit.js` module is as follows:\n\n```javascript\nimport { enableInput, inputEnabled, message, setDiv, token } from \"./index.js\";\nimport { showJobs } from \"./jobs.js\";\n\nlet addEditDiv = null;\nlet company = null;\nlet position = null;\nlet status = null;\nlet addingJob = null;\n\nexport const handleAddEdit = () => {\n  addEditDiv = document.getElementById(\"edit-job\");\n  company = document.getElementById(\"company\");\n  position = document.getElementById(\"position\");\n  status = document.getElementById(\"status\");\n  addingJob = document.getElementById(\"adding-job\");\n  const editCancel = document.getElementById(\"edit-cancel\");\n\n  addEditDiv.addEventListener(\"click\", (e) => {\n    if (inputEnabled && e.target.nodeName === \"BUTTON\") {\n      if (e.target === addingJob) {\n        showJobs();\n      } else if (e.target === editCancel) {\n        showJobs();\n      }\n    }\n  });\n};\n\nexport const showAddEdit = (job) => {\n  message.textContent = \"\";\n  setDiv(addEditDiv);\n};\n```\n\nCreate all these files and then try the application out. You will find that the application now allows for user interaction, and you can navigate between the active divs.\n\nHowever, the application still does not do much, because, of course, there is no code there to communicate with the back end. This is to be added using the `fetch()` function. Fetch makes REST calls, and it returns results asynchronously. In the code that follows, we use the `async/await` pattern, so of course whenever that is used, the surrounding function must be declared as an `async` function.\n\nAlso, we need to disable input during the period in which the `async` operation is in progress. We do this by setting the `inputEnabled` flag using the `enableInput` function that is exported from `index.js`. Our click handlers ignore clicks if they occur while the `inputEnabled` flag is `false`.\n\nWe may get an error when making the request to the server, so the async operations must be surrounded with a `try/catch`. If an error occurs, we notify the user by displaying a message in the page, but we also log the error to the console. You may not want to log all errors to the console in a production application, but it is wise to do it when you are developing, so that you can find your own errors.\n\nFirst, we’ll make register and logon work. For either register or logon, if the step is successful, the back end returns a JWT token. This is stored for use in accessing jobs records.\n\nAdding these capabilities to `register.js` gives the following:\n\n```javascript\nimport {\n  inputEnabled,\n  setDiv,\n  message,\n  token,\n  enableInput,\n  setToken,\n} from \"./index.js\";\nimport { showLoginRegister } from \"./loginRegister.js\";\nimport { showJobs } from \"./jobs.js\";\n\nlet registerDiv = null;\nlet name = null;\nlet email1 = null;\nlet password1 = null;\nlet password2 = null;\n\nexport const handleRegister = () => {\n  registerDiv = document.getElementById(\"register-div\");\n  name = document.getElementById(\"name\");\n  email1 = document.getElementById(\"email1\");\n  password1 = document.getElementById(\"password1\");\n  password2 = document.getElementById(\"password2\");\n  const registerButton = document.getElementById(\"register-button\");\n  const registerCancel = document.getElementById(\"register-cancel\");\n\n  registerDiv.addEventListener(\"click\", async (e) => {\n    if (inputEnabled && e.target.nodeName === \"BUTTON\") {\n      if (e.target === registerButton) {\n        if (password1.value != password2.value) {\n          message.textContent = \"The passwords entered do not match.\";\n        } else {\n          enableInput(false);\n\n          try {\n            const response = await fetch(\"/api/v1/auth/register\", {\n              method: \"POST\",\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: JSON.stringify({\n                name: name.value,\n                email: email1.value,\n                password: password1.value,\n              }),\n            });\n\n            const data = await response.json();\n            if (response.status === 201) {\n              message.textContent = `Registration successful.  Welcome ${data.user.name}`;\n              setToken(data.token);\n\n              name.value = \"\";\n              email1.value = \"\";\n              password1.value = \"\";\n              password2.value = \"\";\n\n              showJobs();\n            } else {\n              message.textContent = data.msg;\n            }\n          } catch (err) {\n            console.error(err);\n            message.textContent = \"A communications error occurred.\";\n          }\n\n          enableInput(true);\n        }\n      } else if (e.target === registerCancel) {\n        name.value = \"\";\n        email1.value = \"\";\n        password1.value = \"\";\n        password2.value = \"\";\n        showLoginRegister();\n      }\n    }\n  });\n};\n\nexport const showRegister = () => {\n  email1.value = null;\n  password1.value = null;\n  password2.value = null;\n  setDiv(registerDiv);\n};\n```\n\nNotice that we’ve now made the click event listener callback function `async`. We then check to see if the user entered matching passwords in the two inputs. If they did, disable clicking on the buttons and then make the `fetch()` call to the register endpoint.\n\nIf the call is successful, we parse the data from the response, display a message to the user, and save the token to local storage using the function exported from `index.js`. We can then display the jobs page. If the call was not successful we will continue to show the register page and will display the error message from the response to the user. If any errors occur, then we catch them and continue to show the register page and show a generic error message to the user.\n\nAfter we’re done processing the call (whether it was successful or not) we re-enable clicking on the buttons.\n\nNotice that we always clear out the input values before we switch to another page. We do not want those to live on in memory.\n\nThe `login.js` module becomes:\n\n```javascript\nimport {\n  inputEnabled,\n  setDiv,\n  token,\n  message,\n  enableInput,\n  setToken,\n} from \"./index.js\";\nimport { showLoginRegister } from \"./loginRegister.js\";\nimport { showJobs } from \"./jobs.js\";\n\nlet loginDiv = null;\nlet email = null;\nlet password = null;\n\nexport const handleLogin = () => {\n  loginDiv = document.getElementById(\"logon-div\");\n  email = document.getElementById(\"email\");\n  password = document.getElementById(\"password\");\n  const logonButton = document.getElementById(\"logon-button\");\n  const logonCancel = document.getElementById(\"logon-cancel\");\n\n  loginDiv.addEventListener(\"click\", async (e) => {\n    if (inputEnabled && e.target.nodeName === \"BUTTON\") {\n      if (e.target === logonButton) {\n        enableInput(false);\n\n        try {\n          const response = await fetch(\"/api/v1/auth/login\", {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n              email: email.value,\n              password: password.value,\n            }),\n          });\n\n          const data = await response.json();\n          if (response.status === 200) {\n            message.textContent = `Logon successful.  Welcome ${data.user.name}`;\n            setToken(data.token);\n\n            email.value = \"\";\n            password.value = \"\";\n\n            showJobs();\n          } else {\n            message.textContent = data.msg;\n          }\n        } catch (err) {\n          console.error(err);\n          message.textContent = \"A communications error occurred.\";\n        }\n\n        enableInput(true);\n      } else if (e.target === logonCancel) {\n        email.value = \"\";\n        password.value = \"\";\n        showLoginRegister();\n      }\n    }\n  });\n};\n\nexport const showLogin = () => {\n  email.value = null;\n  password.value = null;\n  setDiv(loginDiv);\n};\n```\n\nMake these changes and test the application again. You should find that you can register and logon. Logoff doesn’t work right at present, but this can be corrected in `jobs.js` with the following change:\n\n```javascript\n      } else if (e.target === logoff) {\n        setToken(null);\n\n        message.textContent = \"You have been logged off.\";\n\n        jobsTable.replaceChildren([jobsTableHeader]);\n\n        showLoginRegister();\n      }\n```\n\nNote that logoff involves no communication with the back end. The user is logged off by deleting the JWT from memory. We also have to clear the jobs data from memory, for security reasons, so that a non-logged-in user can’t see the previously logged-in user’s jobs. That’s what the replaceChildren does here: it replaces the contents of the `<table id=\"jobs-table\">` element with just the `<tr id=\"jobs-header\">` element and nothing else.\n\nNext we need to make the changes so that we can create job entries. The `addEdit.js` module is changed as follows:\n\n```javascript\naddEditDiv.addEventListener(\"click\", async (e) => {\n  if (inputEnabled && e.target.nodeName === \"BUTTON\") {\n    if (e.target === addingJob) {\n      enableInput(false);\n\n      let method = \"POST\";\n      let url = \"/api/v1/jobs\";\n      try {\n        const response = await fetch(url, {\n          method: method,\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${token}`,\n          },\n          body: JSON.stringify({\n            company: company.value,\n            position: position.value,\n            status: status.value,\n          }),\n        });\n\n        const data = await response.json();\n        if (response.status === 201) {\n          // 201 indicates a successful create\n          message.textContent = \"The job entry was created.\";\n\n          company.value = \"\";\n          position.value = \"\";\n          status.value = \"pending\";\n\n          showJobs();\n        } else {\n          message.textContent = data.msg;\n        }\n      } catch (err) {\n        console.log(err);\n        message.textContent = \"A communication error occurred.\";\n      }\n\n      enableInput(true);\n    } else if (e.target === editCancel) {\n      message.textContent = \"\";\n      showJobs();\n    }\n  }\n});\n```\n\nIn this case, we have to pass the JWT in the header for the call to work.\n\nOnce you have added this code, try out the application again. You are now able to add entries, but you can’t actually see them. Next you add the code to populate the table of jobs entries. Of course, this involves another fetch operation, passing the JWT as for the add. Then the results are used to populate a table.\n\nThere is a somewhat tricky part to this. We want to have edit and delete buttons for each row of the table. But, how do we associate an edit button with the edit operation, and when it is clicked, how do we know which entry is to be edited? This is done as follows. The edit buttons are given a class of `\"editButton\"`, and similarly, the delete buttons are given a class of `\"deleteButton\"`. We can also add an `data-<something>` attribute to the buttons. These are called [data attributes](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset) and in Javascript they correspond to a DOM hash/object called `dataset`. By adding a `data-id` attribute to the elemnet, we can access it via the `dataset.id` property. We want to set that id to be the id of that job (or your custom object), as returned from the database.\n\nIt looks like this in `jobs.js`:\n\n```javascript\nexport const showJobs = async () => {\n  try {\n    enableInput(false);\n\n    const response = await fetch(\"/api/v1/jobs\", {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${token}`,\n      },\n    });\n\n    const data = await response.json();\n    let children = [jobsTableHeader];\n\n    if (response.status === 200) {\n      if (data.count === 0) {\n        jobsTable.replaceChildren(...children); // clear this for safety\n      } else {\n        for (let i = 0; i < data.jobs.length; i++) {\n          let rowEntry = document.createElement(\"tr\");\n\n          let editButton = `<td><button type=\"button\" class=\"editButton\" data-id=${data.jobs[i]._id}>edit</button></td>`;\n          let deleteButton = `<td><button type=\"button\" class=\"deleteButton\" data-id=${data.jobs[i]._id}>delete</button></td>`;\n          let rowHTML = `\n            <td>${data.jobs[i].company}</td>\n            <td>${data.jobs[i].position}</td>\n            <td>${data.jobs[i].status}</td>\n            <div>${editButton}${deleteButton}</div>`;\n\n          rowEntry.innerHTML = rowHTML;\n          children.push(rowEntry);\n        }\n        jobsTable.replaceChildren(...children);\n      }\n    } else {\n      message.textContent = data.msg;\n    }\n  } catch (err) {\n    console.log(err);\n    message.textContent = \"A communication error occurred.\";\n  }\n  enableInput(true);\n  setDiv(jobsDiv);\n};\n```\n\nSo, plug this code into `jobs.js` at the appropriate point, and then try the application again. You should now be able to see the entries for each job.\n\nHowever, the edit and delete buttons don’t actually work. This is because the click handler in `jobs.js` isn’t set to look for them yet. We can add a section to the click handler to remedy this.\n\n```javascript\n      } else if (e.target.classList.contains(\"editButton\")) {\n        message.textContent = \"\";\n        showAddEdit(e.target.dataset.id);\n      }\n```\n\nThe `dataset.id` contains the id of the entry to be edited. That is then passed on to the showAddEdit function. So we need to change that function to do something with this parameter.\n\nThis function is in `addEdit.js`, and should be changed as follows:\n\n```javascript\nexport const showAddEdit = async (jobId) => {\n  if (!jobId) {\n    company.value = \"\";\n    position.value = \"\";\n    status.value = \"pending\";\n    addingJob.textContent = \"add\";\n    message.textContent = \"\";\n\n    setDiv(addEditDiv);\n  } else {\n    enableInput(false);\n\n    try {\n      const response = await fetch(`/api/v1/jobs/${jobId}`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n      });\n\n      const data = await response.json();\n      if (response.status === 200) {\n        company.value = data.job.company;\n        position.value = data.job.position;\n        status.value = data.job.status;\n        addingJob.textContent = \"update\";\n        message.textContent = \"\";\n        addEditDiv.dataset.id = jobId;\n\n        setDiv(addEditDiv);\n      } else {\n        // might happen if the list has been updated since last display\n        message.textContent = \"The jobs entry was not found\";\n        showJobs();\n      }\n    } catch (err) {\n      console.log(err);\n      message.textContent = \"A communications error has occurred.\";\n      showJobs();\n    }\n\n    enableInput(true);\n  }\n};\n```\n\nWith this change, the `add/edit` div will be displayed with the appropriate values. If an add is being done, the function is called with a null parameter, and the form comes up blank with an add button. If an edit is being done, the function is called with the id of the entry to edit. The job is then retrieved from the database and the input fields are populated, and the button is changed to say update. We also store the id of the entry in the `dataset.id` of the `addEdit` div, so we keep track of which entry is to be updated.\n\nSo far, so good, but what happens when the user clicks on the update button? In this case, we need to do a PATCH instead of a POST, and we need to include the id of the entry to be updated in the URL. So we need the following additional changes to addEdit.js:\n\n```javascript\nif (e.target === addingJob) {\n  enableInput(false);\n\n  let method = \"POST\";\n  let url = \"/api/v1/jobs\";\n\n  if (addingJob.textContent === \"update\") {\n    method = \"PATCH\";\n    url = `/api/v1/jobs/${addEditDiv.dataset.id}`;\n  }\n\n  try {\n    const response = await fetch(url, {\n      method: method,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${token}`,\n      },\n      body: JSON.stringify({\n        company: company.value,\n        position: position.value,\n        status: status.value,\n      }),\n    });\n\n    const data = await response.json();\n    if (response.status === 200 || response.status === 201) {\n      if (response.status === 200) {\n        // a 200 is expected for a successful update\n        message.textContent = \"The job entry was updated.\";\n      } else {\n        // a 201 is expected for a successful create\n        message.textContent = \"The job entry was created.\";\n      }\n\n      company.value = \"\";\n      position.value = \"\";\n      status.value = \"pending\";\n      showJobs();\n    } else {\n      message.textContent = data.msg;\n    }\n  } catch (err) {\n    console.log(err);\n    message.textContent = \"A communication error occurred.\";\n  }\n  enableInput(true);\n}\n```\n\nMake these changes, and editing jobs should work. Make sure that adding a new job still work correctly.\n\nThis completes all CRUD operations except for delete. You will notice that the delete buttons don’t work yet. Fix this on your own by following the pattern used for the edit button.\n\nYou’ll call the jobs delete API, and in the URL you will include the ID of the entry to be deleted. Then display the job list page if the delete was successful.\n\n**Note:** There is an error in the implementation of the delete operation in the jobs controller. The instructor’s guidance is to use this line:\n\n```javascript\nres.status(StatusCodes.OK).send();\n```\n\nThis is incorrect, because an empty body is not valid JSON. Change it to:\n\n```javascript\nres.status(StatusCodes.OK).json({ msg: \"The entry was deleted.\" });\n```\n\nIf you do not make this change, an exception is thrown on the front end when you attempt to parse the response body with response.json().\n\nYou should be making commits as you go along. Once you have everything working, do a last `git add` and `git commit`, then push your `week12` branch to your Github repository. Then modify the Render.com deployment you have to point to the new branch. This will cause your new code to be deployed to Render.com. Verify that your application front end is working on Render.com.\n\n### Tips on Getting the Delete to Work\n\n* How do you know that the user wants to make a delete request? Each of the delete buttons is given a class of `deleteButton`. You check for that class in the e.target.\n* How do you know which entry to delete? The id of the entry is stored in the `dataset.id` of the button.\n* How do you do the delete? You need a call to `fetch` with a method of `DELETE` giving the URL of that entry. Be sure you include the JWT in the authorization header. Also, remember that fetch is asynchronous, and should be called in a `try/catch` block.\n* What do you do if the delete succeeds? First, you put a message in the text content of the message paragraph. Second, you redraw the table showing the updated list of entries. The jobs.js module has a function for this.\n* What do you do if the delete fails? Put a message indicating the failure in the message paragraph.\n* Anything else? You don’t want to take input while these asynchronous operations are in progress, so you set the enabled flag before you start them, and clear it afterwards.",
            "codeExample": "",
            "_id": "68f27f4b71abd9d6b34f6a81"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Lesson 11",
          "content": "In this lesson, you create a front end for the Jobs API you created in the previous lesson. Front ends may be created in various ways, for example using React, and they may run in various environments, such as an app for a smart phone. The front end for this lesson is created using just HTML and JavaScript. It runs in a browser, and is loaded from the same Express instance as the API it calls. That is, you will be creating “server-rendered” pages.\n\n**There is no video for this lesson. Instead, there are detailed instructions in the Assignment section.**\n\n**Note:** This lesson appears to be mostly copy/paste — but it may not be depending on what you did the last few weeks! You create forms and tables, but if you used a data model different from Job, as was recommended in lessons 9 and 10, you must modify the HTML and JavaScript so that the forms, tables, and JavaScript variables match your data model. This may seem like a lot of work, and perhaps it is, but once you have completed it, if you used a data model different from the Job model used by the instructor (or you at least substantially extended that model) then you are well on your way to completing your class final project.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a80"
        }
      ]
    },
    {
      "id": "68f27f4b71abd9d6b34f6a83",
      "lessonNumber": 12,
      "title": "Lesson 12",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 12",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "In this project (which continues for the next 3 lessons), you create a jobs application an alternate way from the previous session. This time, using server-side rendering with the `EJS` templating language. If you haven’t started your final project, you can use this project as the basis, using server-side rendering instead of the front-end + back-end model. Of course, to satisfy the requirements of the rubric, you would need to modify the schema to manage objects that are different from the jobs model.\n\n### Creating the Repository\n\nThere is no starter repository for this project, so you will need to create one, with the following steps. First, create a `jobs-ejs` folder/directory on your computer (not in the tree of a previous project), and `cd` (change directories) into it. **Make sure that it is not in the tree of a previous project, that is, running `git status` _should_ return an error after you create the directory**. Next, create the `.gitignore` file and the `.env` file. The `.gitignore` file is critical to make sure your Mongo credentials and the Node libraries are not stored in Github. It should have these lines:\n\n```\n/node_modules\n.env\n.DS_Store\n```\n\nYou can just copy the `.gitignore` file and the `.env` file from the `06-jobs-api` directory. You won’t use the JWT values from `.env`, so you can delete those. The `.env` file is needed for the Mongo credential, and eventually for the session secret.\n\nNext, run `git init` to make the directory a git repository. Then, log into Github and create a new repository called `jobs-ejs`. You create a new repository using the + button in the upper right of your Github screen. You do not use a template, the repository should be public, and you do not create a `README` or a `.gitignore`.\n\n![create new repo button](https://storage.googleapis.com/ctd-course-bucket/courses/68f27f4071abd9d6b34f69f9/images/9772a1a8-ec28-4e34-9c9a-0cc22ef7f5ab.png)\n\nOnce the repository has been created, you need to associate the Github repository with the repository on your laptop. You will see the following screen:\n\n![The github page for a newly created repository](https://storage.googleapis.com/ctd-course-bucket/courses/68f27f4071abd9d6b34f69f9/images/d0419528-d4b6-4d8f-af6d-9acdae6ed229.png)\n\nClick on the clipboard icon next to the URL to copy it. Then, in your laptop session for the jobs-ejs repository, type the following, where the URL is the one you copied to your clipboard\n\n```\ngit remote add origin <paste URL here>\ngit add -A\ngit commit -m \"first commit\"\ngit push origin main\n```\n\nThe local repository is now associated with your Github repository. There isn’t much in it yet, just the `.gitignore`. Now create the `lesson12` branch, where you will do your work.\n\n### Components and Directories\n\nYou need to initialize NPM for your repository. So, do an `npm init`. You can take all the defaults when prompted. This creates the `package.json`, and enables the installation of npm packages. You need to add `scripts` for dev and start to the `package.json` so that you can do `npm run` or `npm run dev`, where the `dev` script runs app.js using `nodemon` and the plain `npm run` runs it using `node`.\n\nYou need to install the following packages:\n\n```\nbcryptjs\nconnect-flash\nconnect-mongodb-session\ncookie-parser\ndotenv\nejs\nexpress\nexpress-async-errors\nexpress-rate-limit\nexpress-session\nhelmet\nhost-csrf\nmongoose\npassport\npassport-local\nxss-clean\n```\n\nYou should also install `eslint`, `prettier`, and `nodemon` as **dev dependencies** if you haven’t installed them globally. You’ve seen some of these packages before, but not others. Each will be explained as we use them.\n\nYou will write to the Mongo database, so to save time, you can copy two directory trees from the `06-jobs-api` directory. You can use the following commands (you may have to adjust these depending on your directory structure / where you’ve set up your folders):\n\n```\ncp -r ../06-jobs-api/db .\ncp -r ../06-jobs-api/models .\n```\n\nNow create the directory structure you will use, in particular the following directories:\n\n```\ncontrollers\nroutes\nmiddleware\nutils\nviews\nviews/partials\n```\n\nYou do not need a `public` directory. The pages are rendered by the `EJS` engine from the `views` directory.\n\nNext, create the boilerplate `app.js`. It should look as follows:\n\n```javascript\nconst express = require(\"express\");\nrequire(\"express-async-errors\");\n\nconst app = express();\n\napp.set(\"view engine\", \"ejs\");\napp.use(require(\"body-parser\").urlencoded({ extended: true }));\n\n// secret word handling\nlet secretWord = \"syzygy\";\napp.get(\"/secretWord\", (req, res) => {\n  res.render(\"secretWord\", { secretWord });\n});\napp.post(\"/secretWord\", (req, res) => {\n  secretWord = req.body.secretWord;\n  res.redirect(\"/secretWord\");\n});\n\napp.use((req, res) => {\n  res.status(404).send(`That page (${req.url}) was not found.`);\n});\n\napp.use((err, req, res, next) => {\n  res.status(500).send(err.message);\n  console.log(err);\n});\n\nconst port = process.env.PORT || 3000;\n\nconst start = async () => {\n  try {\n    app.listen(port, () =>\n      console.log(`Server is listening on port ${port}...`)\n    );\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nstart();\n```\n\nThis boilerplate has crude page not found handling, as well as error handling. Those functions will be moved to middleware eventually. It also has something mysterious to handle the `/secretWord` route. So, if you run this app as is, it will return page not found for all URLs, except for `/secretWord`. That one returns an error — because we haven’t created the secretWord view! Once we have created the view, the `res.render` operation will display it. Note that we also need an `app.use` statement for the body parser.\n\n## First EJS file\n\nCreate `views/secretWord.ejs`. The file should look as follows:\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <link\n      href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"\n      rel=\"stylesheet\"\n      integrity=\"sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi\"\n      crossorigin=\"anonymous\"\n    />\n    <title>Jobs List</title>\n  </head>\n  <body>\n    <p>The secret word is: <%= secretWord %></p>\n    <p>Would you like to change it?</p>\n    <form method=\"POST\">\n      <label name=\"secretWord\"></label>\n      <input name=\"secretWord\" /><br />\n      <button>Submit</button>\n    </form>\n  </body>\n</html>\n```\n\nThis is an EJS file, but it looks just like HTML — except that section in `<%= %>`. Enclosed in those tags is JavaScript that is executed on the server side to modify the template. In this case, it just inserts the value of the `secretWord` variable. This value is passed to the EJS file via the second argument of the `res.render` function call in `app.js`.\n\n**Keep in mind** that the value must be a string or something that JavaScript knows how to convert to a string with a `toString()` method. If you try to pass in an object or some other complex data structure, you’ll likely just see it rendered as `[object Object]`. One way to handle that case would be to use the `JSON.stringify(object)` function to convert an object into a string.\n\nNote also that the `POST` operation does a `redirect`, telling the browser which URL should be displayed after processing is complete. This ends up calling `GET /secretWord` again, this time displaying the updated `secretWord` value.\n\nTry opening the <http://localhost:3000/secretWord> URL. You should see that the secret word is displayed, and it can be changed.\n\nIf the application has a lot of boilerplate, headers and footers and so on, we don’t want to have to duplicate that for every page. So we use “partials”. Create the following files:\n\n`views/partials/head.ejs`\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Jobs List</title>\n  </head>\n  <body>\n```\n\n`views/partials/header.ejs`\n\n```\n<h1>The Jobs EJS Application</h1>\n<hr />\n```\n\n`views/partials/footer.ejs`\n\n```\n<hr>\n<p>A copyright could go here.</p>\n</body>\n</html>\n```\n\nThen change `views/secretWord.ejs` to substitute include statements, so that the whole thing reads:\n\n```\n<%- include(\"partials/head.ejs\") %>\n<%- include(\"partials/header.ejs\") %>\n  <p>The secret word is: <%= secretWord %></p>\n  <p>Would you like to change it?</p>\n  <form method=\"POST\">\n    <label name=\"secretWord\"></label>\n    <input name=\"secretWord\" /><br />\n    <button>Submit</button>\n  </form>\n<%- include(\"partials/footer.ejs\") %>\n```\n\nYou use the `<%- %>` to include HTML from other files. Be sure that you only use it with HTML that you trust, otherwise you could introduce a security exposure. Try the new page out.\n\nThe data we are displaying is just the _value_ of the `secretWord` variable — but we could also insert data into the page that was retrieved from the database, as we’ll see.\n\n### Sessions\n\nThere are a couple problems with the handling of the secret word. First, the value is stored globally — so every user sees the same value. We want the user to see only their own data. The second problem is that the data is stored in the memory of the server process, so when that server is restarted, the value is lost. We fix this using sessions. (Sessions may also be used with front-end+back-end applications.)\n\nSessions are associated with a cookie, as we’ll see, and they are protected with a secret. So add a line to `.env` with this secret, as follows:\n\n```\nSESSION_SECRET=123lkawjg091u82378429\n```\n\nThe secret is some hard to guess string — and you **_never_** want to publicize it to Github! Then, add the following lines to `app.js`. These lines should be added _before_ any of the lines that govern routes, such as the `app.get` and `app.post` statements:\n\n```javascript\nrequire(\"dotenv\").config(); // to load the .env file into the process.env object\nconst session = require(\"express-session\");\napp.use(\n  session({\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n  })\n);\n```\n\nChange the logic so that the secret word is stored and retrieved in the session, as follows:\n\n```javascript\n// let secretWord = \"syzygy\"; <-- comment this out or remove this line\napp.get(\"/secretWord\", (req, res) => {\n  if (!req.session.secretWord) {\n    req.session.secretWord = \"syzygy\";\n  }\n  res.render(\"secretWord\", { secretWord: req.session.secretWord });\n});\napp.post(\"/secretWord\", (req, res) => {\n  req.session.secretWord = req.body.secretWord;\n  res.redirect(\"/secretWord\");\n});\n```\n\n`req.session` is an object that will persist across requests.\n\nThen try the <http://localhost:3000/secretWord> URL. You will see that it works as before, except that if you have different sessions (from different browsers; or from a regular tab and an incognito tab) the value of the secretWord is different. However, if you restart the server, the value is lost. This is because while we’re no longer storing `secretWord` as a global variable, it is still being stored in the memory of the server.\n\nIf you go into developer tools in your browser, and click on the `Application` tab, you can check that a cookie with the name of `connect.sid` has been associated with your browser session.\n\n![screenshot of Application tab for viewing cookies](https://storage.googleapis.com/ctd-course-bucket/courses/68f27f4071abd9d6b34f69f9/images/b912a695-17b2-4c74-8b3e-3edd01c0f37b.png)\n\nThis is the key used to retrieve session data. You can also see that the `HttpOnly` flag is set, so that browser-side code can’t access this cookie.\n\nWe want to store the session data in a durable way. To do this, we’ll use Mongo as a session store. Replace the one line that does the `app.use` for session with all of these lines:\n\n```javascript\nconst MongoDBStore = require(\"connect-mongodb-session\")(session);\nconst url = process.env.MONGO_URI;\n\nconst store = new MongoDBStore({\n  // may throw an error, which won't be caught\n  uri: url,\n  collection: \"mySessions\",\n});\nstore.on(\"error\", function (error) {\n  console.log(error);\n});\n\nconst sessionParms = {\n  secret: process.env.SESSION_SECRET,\n  resave: true,\n  saveUninitialized: true,\n  store: store,\n  cookie: { secure: false, sameSite: \"strict\" },\n};\n\nif (app.get(\"env\") === \"production\") {\n  app.set(\"trust proxy\", 1); // trust first proxy\n  sessionParms.cookie.secure = true; // serve secure cookies\n}\n\napp.use(session(sessionParms));\n```\n\nThese lines cause the session to be stored in Mongo. The bit about `sessionParms.cookie.secure = true` is important but may not be immediately obvious. It is saying that, if the application is running in production, the session cookie won’t work unless SSL is present. It’s a good policy, but as you are not running in production, you don’t have SSL.\n\nThen try the app again. Now you see that the `secretWord` value is preserved even if the server is restarted. If you go to your Mongo database, you can see the session data there — although it is not human-readable.\n\n### Flash Messages\n\nAs the user performs operations, you need to inform them of the result. You do this with the `connect-flash` package. This stores the result of operations so that they can be subsequently displayed to the user. This information can’t be kept in server storage, because otherwise each user could see the others’ messages. And it can’t be stored in the req or res objects, because after an operation, there is typically a redirect, and the information would be lost. Therefore, the `connect-flash` package relies on the _session_. The package also keeps track of whether the message has already been displayed, so that it is only shown once. You can store multiple messages at different severity.\n\nAdd the following code. Note that this code must come after the `app.use` that sets up sessions, because flash depends on sessions:\n\n```\napp.use(require(\"connect-flash\")());\n```\n\nWe want to set some messages into flash. To do this, change the `POST` route for `/secretWord` to look like this:\n\n```javascript\napp.post(\"/secretWord\", (req, res) => {\n  if (req.body.secretWord.toUpperCase()[0] == \"P\") {\n    req.flash(\"error\", \"That word won't work!\");\n    req.flash(\"error\", \"You can't use words that start with p.\");\n  } else {\n    req.session.secretWord = req.body.secretWord;\n    req.flash(\"info\", \"The secret word was changed.\");\n  }\n  res.redirect(\"/secretWord\");\n});\n```\n\nThese messages should be displayed on the next screen. Note that you can have multiple info or error messages. In order for them to be displayed, we need to add code in the view, in the `header.js` partial template, as follows:\n\n```\n<h1>The Jobs EJS Application</h1>\n<% if (errors) {\n  errors.forEach((err) => { %>\n    <div>Error: <%= err %></div>\n<% }) } %>\n<% if (info) {\n  info.forEach((msg) => { %>\n    <div>Info: <%= msg %></div>\n<% }) } %>\n<hr />\n```\n\nWhoa! you may be saying. That doesn’t look like HTML! What will the browser do with it? The answer is that the browser never sees this stuff. The things in `<% %>` are JavaScript, executed on the server side, and the render process removes this and replaces it with the result of the code. There is logic, which is executed but not displayed, in the `<% %>` parts. Then, there is substitution of values, in the `<%= %>` parts, where the equals sign indicates that a value is to be displayed. So, this code checks the `info` and `errors` arrays, displaying values from them if any are present.\n\nBut, the problem is that the `info` and `errors` arrays need to get passed into the EJS file, when the render is called. This could be done as follows:\n\n```javascript\nres.render(\"secretWord\", {\n  secretWord,\n  errors: flash(\"error\"),\n  info: flash(\"info\"),\n});\n```\n\nBut this is a little clumsy, because if we have a bunch of pages we render, every render statement would have to be modified. So, instead, we put the values in `res.locals`. That hash contains values that are always available to the EJS rendering engine. As follows:\n\n```javascript\napp.get(\"/secretWord\", (req, res) => {\n  if (!req.session.secretWord) {\n    req.session.secretWord = \"syzygy\";\n  }\n  res.locals.info = req.flash(\"info\");\n  res.locals.errors = req.flash(\"error\");\n  res.render(\"secretWord\", { secretWord: req.session.secretWord });\n});\n```\n\nThis is how `res.locals` is loaded with the right stuff. However, we’d want to move the `res.locals` statements into a middleware routine that always runs (_after_ the flash middleware, but _before_ any of the routes), and we’ll do that eventually.\n\n### Submitting Your Work\n\nTo submit your work, you add, commit, and push your branch as usual, create a pull request and include a link to your pull request in the homework submission. In the next lesson, we will implement authentication using Passport, and in the final lesson, we’ll manage Jobs entries in the database.",
            "codeExample": "",
            "_id": "68f27f4b71abd9d6b34f6a85"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Lesson 12",
          "content": "In this lesson, you learn `EJS` (Embedded Javascript), a templating language for Express. The templates contain embedded JavaScript, which is executed on the server side. This constructs an ordinary HTML page, but with dynamic content. Because the embedded JavaScript runs on the server, before the page is sent to the client, dynamic content can be delivered, such as information from a database. This is called “server-side rendering”. Except for the embedded JavaScript, the templates are ordinary HTML pages, which may be combined with CSS and client-side JavaScript.\n\nServer-side rendering is in some respects easier than writing first an API and then a front end for it, where the front end makes fetch calls to the API. On the other hand, if you don’t create an API, you can’t access the data via React or other front ends that run outside the application itself. There are other advantages and disadvantages. Frequently, an application will use both methods, using server-side rendering for the administrator user interface and front-end/back-end for the end-user interface.\n\nIn EJS, there are really only three kinds of embedded JavaScript statements:\n\n```\n<%- include 'filename' %>\n<% code %>\n<%= code %>\n```\n\nAll are encased in the `<% %>` sequence.\n\nThe one with the minus in front does an “include” of another template, so that you can have headers, footers, and other partials.\n\nThe one with no minus or equals sign executes code but does not return any change to the HTML. This is used for logic statements, such as `if` statements and `for` loops.\n\nThe one with the equals sign executes code and returns the result in line as HTML.\n\n---\n\nPlease be sure that you understand where each piece of JavaScript executes!\n\nThe JavaScript for your controllers, routes, middleware, etc. executes on the server side. If you do a `console.log` for this code, it appears in the server terminal. The code you put into an EJS file also executes on the server side, to customize the page with variable data before it is sent to the browser.\n\nHowever, you can also put JavaScript into an HTML or EJS page, or load it from a script, where the JavaScript is _not_ within the EJS `<% %>` enclosure. That JavaScript is loaded by the browser and runs in the browser context, which means that it has access to the window and the DOM, but it does not have access to server side data and the database. Anything logged by `console.log` in thatcase would appear in the browser DevTools console.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a84"
        }
      ]
    },
    {
      "id": "68f27f4b71abd9d6b34f6a87",
      "lessonNumber": 13,
      "title": "Lesson 13",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 13",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "In this lesson, you use the `passport` and `passport-local` npm packages to handle user authentication, from within a server-side rendered application.\n\n### First Steps\n\nYou continue to work with the same repository as the previous lesson, but you create a new branch called `lesson13`.\n\nThe user records are stored in the Mongo database, just as for the Jobs API lesson. You have already copied the `models` directory tree from the Jobs API lesson into the `jobs-ejs` repository. The user model is used unchanged. You configure passport to use that model.\n\nTo begin, you will need the following views:\n\n```\nviews/index.ejs\nviews/logon.ejs\nviews/register.ejs\n```\n\nThe `index.ejs` view just shows links to login or register. The `logon.ejs` view collects the email and password from the user. The register collects the name, email, and password for a new user. We want to use the partials as well. We want to modify the header partial to give the name of the logged on user, and to add a logoff button if a user is logged on.\n\n`views/index.ejs`:\n\n```\n<%- include(\"partials/head.ejs\") %>\n<%- include(\"partials/header.ejs\") %>\n<% if (user) { %>\n    <a href=\"/secretWord\">Click this link to view/change the secret word.</a>\n<% } else { %>\n    <a href=\"/sessions/logon\">Click this link to logon.</a>\n    <a href=\"/sessions/register\">Click this link to register.</a>\n<% } %>\n<%- include(\"partials/footer.ejs\") %>\n```\n\n`views/logon.ejs`:\n\n```\n<%- include(\"partials/head.ejs\") %>\n<%- include(\"partials/header.ejs\") %>\n<form method=\"POST\">\n  <div>\n    <label name=\"email\">Enter your email:</label>\n    <input name=\"email\" />\n  </div>\n  <div>\n    <label name=\"password\">Enter your password:</label>\n    <input type=\"password\" name=\"password\" />\n  </div>\n  <div>\n    <button>Logon</button>\n    <a href=\"/\">\n      <button type=\"button\">Cancel</button>\n    </a>\n  </div>\n</form>\n<%- include(\"partials/footer.ejs\") %>\n```\n\n`views/register.js`\n\n```\n<%- include(\"partials/head.ejs\") %>\n<%- include(\"partials/header.ejs\") %>\n<form method=\"POST\">\n  <div>\n    <label name=\"name\">Enter your name:</label>\n    <input name=\"name\" />\n  </div>\n  <div>\n    <label name=\"email\">Enter your email:</label>\n    <input name=\"email\" />\n  </div>\n  <div>\n    <label name=\"password\">Enter your password:</label>\n    <input type=\"password\" name=\"password\" />\n  </div>\n  <div>\n    <label name=\"password1\">Confirm your password:</label>\n    <input type=\"password\" name=\"password1\" />\n  </div>\n  <div>\n    <button>Register</button>\n    <a href=\"/\">\n      <button type=\"button\">Cancel</button>\n    </a>\n  </div>\n</form>\n<%- include(\"partials/footer.ejs\") %>\n```\n\nRevised `views/partials/header.ejs`:\n\n```\n<h1>The Jobs EJS Application</h1>\n<% if (user) { %>\n   <p>User <%= user.name %> is logged on.</p>\n   <form method=\"POST\" action=\"/sessions/logoff\">\n   <button>Logoff</button>\n   </form>\n<% } %>\n<% if (errors) {\n    errors.forEach((err) => { %>\n      <div>\n        Error: <%= err %>\n      </div>\n    <% })\n  } %>\n  <% if (info) {\n    info.forEach((msg) => { %>\n      <div>\n        Info: <%= msg %>\n      </div>\n    <% })\n  } %>\n<hr />\n```\n\nThese changes won’t suffice to do anything in the application, until routes are added to match. We need to follow best practices, with separate route and controller files.\n\n### Router and Controller\n\nCreate a file `routes/sessionRoutes.js`, as follows:\n\n```javascript\nconst express = require(\"express\");\n// const passport = require(\"passport\");\nconst router = express.Router();\n\nconst {\n  logonShow,\n  registerShow,\n  registerDo,\n  logoff,\n} = require(\"../controllers/sessionController\");\n\nrouter.route(\"/register\").get(registerShow).post(registerDo);\nrouter\n  .route(\"/logon\")\n  .get(logonShow)\n  .post(\n    // passport.authenticate(\"local\", {\n    //   successRedirect: \"/\",\n    //   failureRedirect: \"/sessions/logon\",\n    //   failureFlash: true,\n    // })\n    (req, res) => {\n      res.send(\"Not yet implemented.\");\n    }\n  );\nrouter.route(\"/logoff\").post(logoff);\n\nmodule.exports = router;\n```\n\nIgnore the passport lines for the moment. This just sets up the routes. We need to create a corresponding file `controllers/sessionController.js`. Here we use the `User` model. However, the file you copied makes some references to the JWT library. You must edit `models/User.js` to remove those references in order for `User.js` to load. We aren’t using JWTs in this project.\n\n```javascript\nconst User = require(\"../models/User\");\nconst parseVErr = require(\"../util/parseValidationErr\");\n\nconst registerShow = (req, res) => {\n  res.render(\"register\");\n};\n\nconst registerDo = async (req, res, next) => {\n  if (req.body.password != req.body.password1) {\n    req.flash(\"error\", \"The passwords entered do not match.\");\n    return res.render(\"register\", {  errors: flash(\"errors\") });\n  }\n  try {\n    await User.create(req.body);\n  } catch (e) {\n    if (e.constructor.name === \"ValidationError\") {\n      parseVErr(e, req);\n    } else if (e.name === \"MongoServerError\" && e.code === 11000) {\n      req.flash(\"error\", \"That email address is already registered.\");\n    } else {\n      return next(e);\n    }\n    return res.render(\"register\", {  errors: flash(\"errors\") });\n  }\n  res.redirect(\"/\");\n};\n\nconst logoff = (req, res) => {\n  req.session.destroy(function (err) {\n    if (err) {\n      console.log(err);\n    }\n    res.redirect(\"/\");\n  });\n};\n\nconst logonShow = (req, res) => {\n  if (req.user) {\n    return res.redirect(\"/\");\n  }\n  res.render(\"logon\", {\n    errors: req.flash(\"error\"),\n    info: req.flash(\"info\"),\n  });\n};\n\nmodule.exports = {\n  registerShow,\n  registerDo,\n  logoff,\n  logonShow,\n};\n```\n\nWe have two endpoints that handle just rendering an EJS page, `registerShow` and `logonShow`.\n\nWe then have endpoints for actually performing the logoff and register actions. We don’t need a controller handler for login, because Passport handles that for us.\n\nThe `registerDo` handler will check if the two passwords the user entered match, and refresh the page otherwise. If all is good there, it will create a user in the database and redirect to the home page. The creation of the user entry in Mongo is just the same as it was for the Jobs API. We also have some error handling cases here.\n\nIf there is a Mongoose validation error when creating a user record, we need to parse the validation error object to return the issues to the user in a more helpful format, and we do that in the file util/parseValidationErrs.js:\n\n```javascript\nconst parseValidationErrors = (e, req) => {\n  const keys = Object.keys(e.errors);\n  keys.forEach((key) => {\n    req.flash(\"error\", key + \": \" + e.errors[key].properties.message);\n  });\n};\n\nmodule.exports = parseValidationErrors;\n```\n\nWe need some middleware to load `res.locals` with any variables we need, like the logged in user and flash properties. Create `middleware/storeLocals.js`:\n\n```javascript\nconst storeLocals = (req, res, next) => {\n  if (req.user) {\n    res.locals.user = req.user;\n  } else {\n    res.locals.user = null;\n  }\n  res.locals.info = req.flash(\"info\");\n  res.locals.errors = req.flash(\"error\");\n  next();\n};\n\nmodule.exports = storeLocals;\n```\n\nNow, we need a couple of `app.use` statements. Add these lines right after the `connect-flash` line:\n\n```javascript\napp.use(require(\"./middleware/storeLocals\"));\napp.get(\"/\", (req, res) => {\n  res.render(\"index\");\n});\napp.use(\"/sessions\", require(\"./routes/sessionRoutes\"));\n```\n\nThe storeLocals middleware sets the values for errors, info, and user, but in registerDo above, we have to pass the value for errors on the render call, because we changed the value of the flash errors after storeLocals ran.\n\nWe are now using the database. So, we need to connect to it at startup. You need a file, `db/connect.js`. Check that it looks like the following:\n\n```javascript\nconst mongoose = require(\"mongoose\");\n\nconst connectDB = (url) => {\n  return mongoose.connect(url, {});\n};\n\nmodule.exports = connectDB;\n```\n\nThen add this line to `app.js`, just before the listen line:\n\n```javascript\nawait require(\"./db/connect\")(process.env.MONGO_URI);\n```\n\nThen try the application out, starting at the `\"/\"` URL. You can try each of the new views. But you still can’t logon. The logon operation is commented out, because Passport is not set up.\n\n### Configuring Passport\n\nTo use Passport, you have to tell it how to authenticate users, retrieving them from the database. Create a file `passport/passportInit.js`, as follows:\n\n```javascript\nconst passport = require(\"passport\");\nconst LocalStrategy = require(\"passport-local\").Strategy;\nconst User = require(\"../models/User\");\n\nconst passportInit = () => {\n  passport.use(\n    \"local\",\n    new LocalStrategy(\n      { usernameField: \"email\", passwordField: \"password\" },\n      async (email, password, done) => {\n        try {\n          const user = await User.findOne({ email: email });\n          if (!user) {\n            return done(null, false, { message: \"Incorrect credentials.\" });\n          }\n\n          const result = await user.comparePassword(password);\n          if (result) {\n            return done(null, user);\n          } else {\n            return done(null, false, { message: \"Incorrect credentials.\" });\n          }\n        } catch (e) {\n          return done(e);\n        }\n      }\n    )\n  );\n\n  passport.serializeUser(async function (user, done) {\n    done(null, user.id);\n  });\n\n  passport.deserializeUser(async function (id, done) {\n    try {\n      const user = await User.findById(id);\n      if (!user) {\n        return done(new Error(\"user not found\"));\n      }\n      return done(null, user);\n    } catch (e) {\n      done(e);\n    }\n  });\n};\n\nmodule.exports = passportInit;\n```\n\nHere we are registering a “strategy” to tell Passport how to handle requests that we pass to it `passport.use` is a function that takes the name you want to give this passport strategy (here we’re using `\"local\"`) and the strategy as the second argument, where we’re passing in a `new LocalStrategy` from the `passport-local` library.\n\nThe `LocalStrategy` constructor takes two arguments: an options object, and a callback function. The options object expects us to tell the strategy what field on the request will have the user identifier, and what field will have the password. Here, we tell it to look for `\"email\"` as the identifier, and `password` for the password.\n\nThe second argument passed to the `LocalStrategy` constructor is the callback function that will be called when we do `passport.authenticate(...)` in the login route in `sessionRoutes.js`. The `local-strategy` library will extract the `email` and `password` fields that we defined in the options/first argument, from the `req.body`. If it doesn’t find those fields, it will return a 400 error. If it does find them, then it will then pass those (along with a `done` callback) to the function we’ve defined above. It’s up to us then to write the code specific to our application, that handles checking if the user exists and has used to correct password.\n\nThe `done` callback accepts three arguments:\n\n1. An error, if there is one, otherwise just pass in `null`\n2. The user object, if the user is found and used valid credentials, otherwise `false`\n3. An object with a `message` property and `type`, this can be used in both error and success cases to show flash messages. Here we’e only using it in non-error failure cases (user not found or wrong credentials used).\n\nIn addition to registering our local strategy, we also define `serializeUser` and `deserializeUser` functions on the `passport` object.\n\n`serializeUser` is used when saving a user to the request session object. We can’t save an object to the session cookie, so we need to “serialize” it a.k.a. encode it as a string. In the above function, we’re doing that by telling Passport to save just the user id to the session cookie.\n\nThen when Passport is handling a protected route, it will use the `deserializeUser` function to retrieve the user from the database, using the id that was saved to the session cookie.\n\nYou can now add the following lines to `app.js`, right _after_ the `app.use` for session (Passport relies on session):\n\n```javascript\nconst passport = require(\"passport\");\nconst passportInit = require(\"./passport/passportInit\");\n\npassportInit();\napp.use(passport.initialize());\napp.use(passport.session());\n```\n\nFirst we call the `passportInit` function that we created in the previous section. This registers our `local` Passport strategy, and sets up the `serializeUser` and `deserializeUser` functions onto the `passport` object.\n\nThen we call `passport.initialize()` (which sets up Passport to work with Express and sessions) and `passport.session()` (which sets up an Express middleware that runs on all requests, checks the session cookie for a user id, and if it finds one, deserializes and attaches it to the `req.user` property).\n\nFinally, you can now uncomment the lines having to do with Passport in `routes/sessionRoutes.js`, so that the require statement for Passport is included, and so that the route for logon looks like\n\n```javascript\nrouter\n  .route(\"/logon\")\n  .get(logonShow)\n  .post(\n    passport.authenticate(\"local\", {\n      successRedirect: \"/\",\n      failureRedirect: \"/sessions/logon\",\n      failureFlash: true,\n    })\n  );\n```\n\nThis means that when someone sends a `POST` request to the `/sessions/logon` path, Passport will call the function we defined earlier and registered to the name `\"local\"`. If that function completes successfully (`done(...)` is called with no error argument), then it will redirect the page to the `successRedirect` page. If there is an error, then it will redirect to the `failureRedirect` page, and also set a flash message with the `message` property from the object we passed to `done(...)`.\n\nSince we’re letting Passport handle setting the `req.flash` properties now, we can remove the lines in `controllers/sessionController.js` that set the flash messages for the `loginShow` handler. So that should now just look like:\n\n```javascript\nconst logonShow = (req, res) => {\n  if (req.user) {\n    return res.redirect(\"/\");\n  }\n  res.render(\"logon\");\n};\n```\n\nAfter that, try logon for one of the accounts you have created. You should see that you are logged in and can access the `secretWord` page. You should also see appropriate error messages for bad logon credentials. Also, test logoff.\n\n### Protecting a Route\n\nTo protect a route, you need some middleware, as follows.\n\n`middleware/auth.js`:\n\n```javascript\nconst authMiddleware = (req, res, next) => {\n  if (!req.user) {\n    req.flash(\"error\", \"You can't access that page before logon.\");\n    res.redirect(\"/\");\n  } else {\n    next();\n  }\n};\n\nmodule.exports = authMiddleware;\n```\n\n`req.user` is injected into the `req` object by `passport.session()`. We can check if it exists (a.k.a. if the user is logged-in) in this middleware and use that to determine if the non-logged-in requester should be redirected to the home page, or if the logged-in user should be allowed to continue to the next middleware or controller handler function.\n\nWe want to protect any route for the `\"/secretWord\"` path. The best practice is to put the code for those routes into a router file, as follows.\n\n`routes/secretWord.js`:\n\n```javascript\nconst express = require(\"express\");\nconst router = express.Router();\n\nrouter.get(\"/\", (req, res) => {\n  if (!req.session.secretWord) {\n    req.session.secretWord = \"syzygy\";\n  }\n\n  res.render(\"secretWord\", { secretWord: req.session.secretWord });\n});\n\nrouter.post(\"/\", (req, res) => {\n  if (req.body.secretWord.toUpperCase()[0] == \"P\") {\n    req.flash(\"error\", \"That word won't work!\");\n    req.flash(\"error\", \"You can't use words that start with p.\");\n  } else {\n    req.session.secretWord = req.body.secretWord;\n    req.flash(\"info\", \"The secret word was changed.\");\n  }\n\n  res.redirect(\"/secretWord\");\n});\n\nmodule.exports = router;\n```\n\nWe could further refactor this by moving the code for handling the routes (`(req, res) => {...}`) a controller file, like we’ve done for the session routes, but we’ll leave it like this for now.\n\nNext let’s replace the `app.get` and `app.post` statements for the `\"/secretWord\"` routes in `app.js` with these lines:\n\n```javascript\nconst secretWordRouter = require(\"./routes/secretWord\");\napp.use(\"/secretWord\", secretWordRouter);\n```\n\nThen try out the secretWord page to make sure it still works. Turning on protection is simple. You add the authentication middleware to the route above as follows:\n\n```javascript\nconst auth = require(\"./middleware/auth\");\napp.use(\"/secretWord\", auth, secretWordRouter);\n```\n\nThat causes the authentication middleware to run before the `secretWordRouter`, and it redirects if any requests are made for those routes before logon. Try it out: login and verify that you can see and change the secretWord. Then log off and try to go to the `\"/secretWord\"` URL.\n\n### Submitting Your Work\n\nAs usual, add and commit your changes and push the `lesson13` branch to your Github. Then create the pull request and include the link in your homework submission.",
            "codeExample": "",
            "_id": "68f27f4b71abd9d6b34f6a89"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Lesson 13",
          "content": "When you are creating APIs, you can perform authentication using JavaScript Web Tokens (JWTs). The front end makes an API call passing credentials to the back end, and the back end returns a token, either in the body of the response or by setting a cookie. The front end then passes this token to the back end on all subsequent requests.\n\nWhen the application does not have a separate front end to invoke the APIs, only the cookie approach can work. The browser is making the requests, and browsers cannot call arbitrary APIs or send authorization headers. But there has to be _some_ way to save state, such as the state of being logged on. For applications without a way to call various API endpoints, like server-side rendered applications (that don’t have any client-side scripts), this is done using “sessions”, and sessions are established and maintained using cookies.\n\nThis way of handling security can be used for APIs as well, if the APIs are to be called from a browser. And, when using a browser, the cookie based approach is more secure, because sensitive information such as the JWT is not stored in local storage. However, when one server calls another, the cookie-based approach can’t be used, as cookies only have meaning for browsers.\n\nThis is the general pattern that would be used in a cookie-based authentication flow:\n\n1. The browser requests the logon page from the server (`GET` request), and then sends the credentials (eg: username and password) that were obtained from the user (`POST` request).\n2. The server verifies the credentials, and if verification is successful, the server sends a response that includes a `set-cookie` response header to the browser. The cookie is a cryptographically signed string, signed with a secret key so that it can’t be counterfeited by a malicious user. The browser automatically includes the cookie in the header of all subsequent requests to the same URL, until the cookie expires.\n3. For all protected routes, the server has middleware that validates the cookie. Different browser sessions from different users have different cookie values, so the server can tell which user is making the request. On the server side, the cookie is used as a key to access session state data, which is kept on the server. This state data is the user’s session.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a88"
        }
      ]
    },
    {
      "id": "68f27f4b71abd9d6b34f6a8b",
      "lessonNumber": 14,
      "title": "Lesson 14",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 14",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "You continue to work in the `jobs-ejs` repository. Create a branch called `lesson14` for this week’s work.\n\n### Fixing the Security\n\nPassport is using the session cookie to determine if the user is logged in. This creates a security vulnerability called “cross site request forgery” (CSRF). We will demonstrate this.\n\nTo see this, clone **[this repository](https://github.com/Code-the-Dream-School/csrf-attack)** into a separate directory, outside of the current `jobs-ejs` folder. Then, within the directory you cloned, install packages with `npm install` and run the app with `node app`. This will start another express application listening on port **4000** of your local machine. This is the attacking code. It could be running anywhere on the Internet — that has nothing to do with the attack.\n\nYou should have two browser tabs open, one for localhost:3000, and one for localhost:4000\\. The one at localhost:4000 just shows a button that says Click Me! **Don’t click it yet**. Use the `jobs-ejs` application in the 3000 tab to set the secret string to some value. Then close the tab for localhost:3000\\. Then open a new tab for localhost:3000\\. Then check the value of the secret string. So far so good — it still has the value you set. If you log off, your session is discarded. Try this: Log off. Then click the button in the localhost:4000 tab. Then log back on and view the secret string. It is back to syzygy. Set it to a custom value.\n\nNow, without logging off of jobs-ejs , click the button in the 4000 tab. Then refresh the /secretWord page in `jobs-ejs`. Hey, what happened! (By the way, this attack would succeed even if you closed the 3000 tab entirely.)\n\nYou see, the other application sends a request to your application in the context of your browser — and that browser request automatically includes the cookie. So, the application thinks the request comes from a logged on user, and honors it. If the application, as a result of a form post, makes database changes, or even transfers money, the attacker could do that as well.\n\nSo, how to fix this? This is the purpose of the host-csrf package you installed at the start of the project. Follow the instructions **[here](https://www.npmjs.com/package/host-csrf#:~:text=The%20csrf%20middleware,Example%3A)** to integrate the package with your application. You will need to change app.js as well as **each of the forms** in your EJS files. You can use `process.env.SESSION_SECRET` as your `cookie-parser` secret. Note that the `app.use` for the CSRF middleware must come _after_ the cookie parser middleware and _after_ the body parser middleware, but _before_ any of the routes. You will see a message logged to the console that the CSRF protection is not secure. That is because you are using HTTP, not HTTPS, so the package is less secure in this case, but you would be using HTTPS in production. As you will see, it stops the attack.\n\nRe-test, first to see that your application still works, and second, to see that the attack no longer works. (A moral: Always log off of sensitive applications before you surf, in case the sensitive application is vulnerable in this way. Also note that it does not help to close the application, as the cookie is still present in the browser. You have to log off to clear the cookie. Even restarting the browser does not suffice.)\n\nEnabling CSRF protection in the project is an _important_ part of this lesson — don’t omit it! By the way, the CSRF attack only works when the credential is in a cookie. It doesn’t work if you use JWTs in the authorization header.  However, as we've seen, to send JWTs in an authorization header, you have to store sensitive data in browser local storage, which is always a bad idea.\n\n### A Couple of Tips\n\nThe rest of this lesson shows how to build a dynamic database application with **no client-side JavaScript.** Of course, in real-world applications, you’ll often have client side JavaScript, but this lesson shows that you can do a lot of things without it.\n\nHowever, it does necessitate some differences in approach. If all you have on the client side is HTML, the client can only send `GET` requests (for links) or `POST` requests (for submitting a form). You can’t send `PUT`, `PATCH`, or `DELETE` operations from HTML — unless you add in some client-side JavaScript. So, in this lesson, all routes are GET and POST routes.\n\nYou are going to get a list of job listings and display them in a table. You are also going to enable the user to create a new job listing, edit an existing one, or delete one from the list. As always, a given user can only access the entries they own, and not other people’s. Because you can’t do `PUT`, `PATCH`, or `DELETE`, you’ll do `POST` operations for each of these, giving a different URL for each so that the server knows what to do. **Never add, update, or delete data using a `GET`.** That would introduce security vulnerabilities.\n\nYour table should have columns for each the attributes (company, position, status) of each job listing. In addition, it should have buttons on each row to edit or delete an entry. Editing an entry starts with a `GET` to display a form. Deleting an entry just sends a `POST`. So, you should have routes something like this:\n\n```\nGET /jobs (display all the job listings belonging to this user)\nPOST /jobs (Add a new job listing)\nGET /jobs/new (Put up the form to create a new entry)\nGET /jobs/edit/:id (Get a particular entry and show it in the edit box)\nPOST /jobs/update/:id (Update a particular entry)\nPOST /jobs/delete/:id (Delete an entry)\n```\n\nIn your table, you’ll have a button for edit and a button for delete. The button for edit should do a GET, so that’s a link. A good way to make a link look like a button is to put the button inside the link, as follows:\n\n```\n<a href=\"/jobs/edit/2093410392\"><button type=\"button>edit</button></a>\n```\n\nOf course, the URL in the href should have the actual ID of the entry. The button for delete should do a POST. How do you make a button do a POST? As follows:\n\n```\n<form method=\"POST\" action=\"/jobs/delete/0qw9a09as0d9f\" style=\"display: inline\">\n  <button>delete</button>\n  <input type=\"hidden\" name=\"_csrf\" value=\"<%= _csrf %>\" />\n</form>\n```\n\nThis is really a form masquerading as a button. And, because it’s a form, you have to add the `_csrf` token, or your CSRF protection won’t let the operation through. The `display: inline` allows this to line up on the table row.\n\nOk, so how to build the table? The `GET` for `\"/jobs\"` comes in, and your router calls a function in your controller to pull all the job listings for that user from the database into a jobs array (which might be empty). Then the controller function makes the following call:\n\n```javascript\nres.render(\"jobs\", { jobs });\n```\n\nThis render call is going to load and parse` /views/jobs.ejs`, passing the array as a local variable to that template. Now you need to construct the table, using EJS code. It will look something like this:\n\n```\n    <h2>Jobs List</h2>\n    <table id=\"jobs-table\">\n      <tr id=\"jobs-table-header\">\n        <th>Company</th>\n        <th>Position</th>\n        <th>Status</th>\n        <th colspan=\"2\"></th>\n      </tr>\n      <% if (jobs && jobs.length) { %>\n        <% jobs.forEach((job) => { %>\n          <tr>\n            <td><%= job.company %></td>\n            <td><%= job.position %></td>\n            <td><%= job.status %></td>\n            <td><button type=\"button\">edit</button></td>\n            <td>button type=\"button\">delete</button></td>\n          </tr>\n        <% }) %>\n      <% } %>\n    </table>\n```\n\nOf course, you also have `include` statements for the header and footer in this ejs file. You see the conditional JavaScript logic in the EJS brackets `<% %>.` But, the buttons aren’t going to do anything yet. So you need to substitute this for the edit button:\n\n```\n<a href=\"/jobs/edit/<%= job.id %>\">\n  <button type=\"button\">edit</button>\n</a>\n```\n\nThat puts the actual id of the job listing into the URL. Similarly, for the delete button, you have to build one of those button-only forms described above, and it should have the following as its action attribute:\n\n```\naction=\"/jobs/delete/<%= job.id %>\"\n```\n\nSo that the actual id of the entry to delete is included in the URL on the `POST`. Enough on the tips. Here are the steps to complete the project.\n\n### Steps\n\n1. Create `routes/jobs.js` and `controllers/jobs.js`. The router should have each of the routes previously described, and the controller should have functions to call when each route is invoked. Remember that `req.params` will have the id of the entry to be edited, updated, or deleted. You might want to start with simple `res.send()` operations to make sure each of the routes and controller functions are getting called as expected.\n2. In `app.js`, `require` the jobs router, and add an `app.use` statement for it, at an appropriate place in the code. The `app.use` statement might look like:\n\n```javascript\napp.use(\"/jobs\", auth, jobs);\n```\n\nYou need to include the auth middleware in the `app.use`, because these are protected routes and the requester must be a logged on user.\n\n1. Test your routes. You can test the `GET` routes from the browser. For the `POST` routes, you’ll need to use Postman.\n2. Create `views/jobs.ejs`. That should have the table described above, plus a button to add a new entry.\n3. Create `views/job.ejs` (note the singular form here rather than plural like in step 4). That should have the fields so that you can create an entry. You’ll want to use the same form for adding and editing. When adding, you’ll do `res.render(\"job\", { job: null })`. That will tell `job.ejs` that it is doing an add because there’s no value in the `job` local variable. When editing, you’ll do `res.render(\"job\", { job })`. When a non-null entry is passed to `job.ejs`, then the form knows it is doing an edit, so the fields are populated and the button says update. Note that the action for the form is different for each case. If job is null, then `action=\"/job\"`. But if job is not null, then `action=\"/job/update/<%= job.id %>` so that the update route is called.\n4. Add the necessary Mongo calls to `controllers/jobs.js`. You first require the `models/Job` model, so that you can do `Job.create`, `Job.findOne`, etc. As always, have appropriate error handling. You can use `util/parseValidationErrs.js` to handle validation errors. You can use `flash` to pass error and information messages to the user. Be sure that if you do an edit or update or delete for an entry, that that entry belongs to the active user. Here’s a hint: Passport stores the active user in `req.user`. So you can use `req.user._id` for your `createdBy` value.\n5. Add a link to `index.html` for the `/jobs` URL.\n6. Try it out!\n7. There is one more step. You need to make your application more secure! You should configure the helmet, xss-clean, and express-rate-limit packages, just as you did for Lesson 10\\. Then try the application out one more time. CORS is not needed in this case.\n\n### Submitting Your Work\n\nThe usual steps apply.",
            "codeExample": "",
            "_id": "68f27f4b71abd9d6b34f6a8d"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Lesson 14",
          "content": "You have created a project with EJS that includes various views, user registration and logon, and secure routes. What remains is to perform CRUD operations to the database. Once you can do that, you can use EJS for a variety of projects. There are no new concepts in this lesson. It is just practice of the techniques you have learned.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a8c"
        }
      ]
    },
    {
      "id": "68f27f4b71abd9d6b34f6a8f",
      "lessonNumber": 15,
      "title": "# Types of Testing",
      "status": "pending",
      "assignment": {
        "title": "Assignment for Lesson 15",
        "objective": "No objective specified",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [
          {
            "taskNumber": 1,
            "title": "Task 1",
            "description": "You continue with the same jobs-ejs repository from your previous lesson, but create a new branch called lesson 15.\n\nThe instructions below are for the Job model. If you are using a different or modified model, so as to prepare for your final project, you will have to adjust the code below.\n\nThe first step is to install the packages you will need.  These are development dependencies -- you do not need them in your runtime, if you deploy this application to the internet -- so you install them with the ```--save-dev``` flag.  You need mocha, chai, puppeteer, @faker-js/faker, and factory-bot, as follows:\n```\nnpm install --save-dev mocha\nnpm install --save-dev chai\nnpm install --save-dev chai-http\nnpm install --save-dev factory-bot\nnpm install --save-dev @faker-js/faker\nnpm install --save-dev puppeteer\n```\nA suggestion: You probably should update the connect-mongodb-session package. There have been some serious security bugs in that package, now fixed.  When you have completed the above npm install operations, check your package.json.  In the devDependencies stanza you should have entries for the packages above.  Verify that your chai and chai-http entries are for some level of version 5 of those packages, as the instructions below are specific to version 5.\n\n## Setting Up To Test\n\nCreate a test directory in your repository. This is where you will put the actual test cases.  Edit your\n.env file.  Currently you have a line for MONGO_URI.  Duplicate the line, and then change the copy to MONGO_URI_TEST.  Add \"-test\" onto the end of the value.  This gives you a separate test database.  Edit your package.json.  In the scripts stanza, the line for \"test\" should be changed to read:\n```\n  \"test\": \"NODE_ENV=test mocha tests/*.js --timeout 5000 --exit\",\n```\nwhich will cause the tests to run.  It also sets the NODE_ENV environment variable, which we'll use to load the test version of the database.  Edit your app.js.  You'll have a line that reads something like:\n```javascript\n    const url = process.env.MONGO_URI;\n```\nYou should change it to look something like the following:\n```javascript\nlet mongoURL = process.env.MONGO_URI;\nif (process.env.NODE_ENV == \"test\") {\n  mongoURL = process.env.MONGO_URI_TEST;\n}\n```\nand then change url to mongoURL in the section that starts ```const store = ```.\nThe point of this is so that your testing doesn't interfere with your production database, and also so that your production or development data doesn't interfere with your testing.  Also, you want to have a function that will bring the database to a known state, so that previous tests don't cause subsequent ones to give false results.  Create a file util/seed_db.js.  It should read as follows:\n```javascript\nconst Job = require(\"../models/Job\");\nconst User = require(\"../models/User\");\nconst faker = require(\"@faker-js/faker\").fakerEN_US;\nconst FactoryBot = require(\"factory-bot\");\nrequire(\"dotenv\").config();\n\nconst testUserPassword = faker.internet.password();\nconst factory = FactoryBot.factory;\nconst factoryAdapter = new FactoryBot.MongooseAdapter();\nfactory.setAdapter(factoryAdapter);\nfactory.define(\"job\", Job, {\n  company: () => faker.company.name(),\n  position: () => faker.person.jobTitle(),\n  status: () =>\n    [\"interview\", \"declined\", \"pending\"][Math.floor(3 * Math.random())], // random one of these\n});\nfactory.define(\"user\", User, {\n  name: () => faker.person.fullName(),\n  email: () => faker.internet.email(),\n  password: () => faker.internet.password(),\n});\n\nconst seed_db = async () => {\n  let testUser = null;\n  try {\n    const mongoURL = process.env.MONGO_URI_TEST;\n    await Job.deleteMany({}); // deletes all job records\n    await User.deleteMany({}); // and all the users\n    testUser = await factory.create(\"user\", { password: testUserPassword });\n    await factory.createMany(\"job\", 20, { createdBy: testUser._id }); // put 30 job entries in the database.\n  } catch (e) {\n    console.log(\"database error\");\n    console.log(e.message);\n    throw e;\n  }\n  return testUser;\n};\n\nmodule.exports = { testUserPassword, factory, seed_db };\n```\nA couple of new ideas are introduced above.  First, faker is being used to generate somewhat random but plausible data.  Second, we are using factories to automate the creation of data, which is being written to the database.\n\n## Chai 5 and Chai-Http 5\n\nThese packages are now ESM only! This was, in my humble opinion, a questionable move on the part of the developers, and they made quite a few other breaking changes.  But we can accommodate these changes, without converting to ESM modules.  (Some students are using ESM modules for these exercises.  If you are doing this, discuss matters with your mentors if you have trouble.)\n\nFor Chai 4 and Chai-http 4, we could do:\n```javascript\nconst chai = require('chai')\nconst chaiHttp = require('chai-http')\nchai.use(chaiHttp)\n```\nThis would give you access to chai.expect() (for evaluating results) and chai.request() (for sending http requests to the server and getting back the results).  This is not going to work for V5 of these packages: You can't use request() to load an ESM only module. Also you can only call chai.use() once, for all of your test files and cases.  So, we need the following utility module, util\\get_chai.js:\n```javascript\nlet chai_obj = null;\n\nconst get_chai = async () => {\n  if (!chai_obj) {\n    const { expect, use } = await import(\"chai\");\n    const chaiHttp = await import(\"chai-http\");\n    const chai = use(chaiHttp.default);\n    chai_obj = { expect: expect, request: chai.request };\n  }\n  return chai_obj;\n};\n\nmodule.exports = get_chai;\n```\nIn this way, we avoid using request(), and we can ensure that chai.use() is only called once.  But, get_chai() is asynchronous.  When we use Mocha, we can't call an asynchronous function in the mainline of a test file, because mocha won't wait for the promise to resolve.  Also, describe() functions can't be passed asynchronous functions.  We can and should pass asynchronous functions to it() functions, for the individual tests.  So, this is where we call get_chai(), inside each asynchronous function passed to it().\n\n(Some students may be using EJS files.  This is somewhat easier, in that you can use the import statement instead of the import() asynchronous function.  However, you still need a utility module to ensure that use() is only called once.)\n\n## Unit Testing a Function\n\nCreate a file, utils/multiply.js.  It should export a function, multiply(), that takes two arguments and returns the product.  Now we can write a unit test, in tests/test_multipy.rb:\n```javascript\nconst multiply = require(\"../util/multiply\");\nconst get_chai = require(\"../util/get_chai\");\n\ndescribe(\"testing multiply\", () => {\n  it(\"should give 7*6 is 42\", async () => {\n    const { expect } = await get_chai();\n    expect(multiply(7, 6)).to.equal(42);\n  });\n  it('should give 7*6 is 97', async () => {\n    const {expect} = await get_chai();\n    expect(multiply(7,6)).to.equal(97);\n  });\n});\n```\nHere we get the value for expect() several times.  By default, the test cases run in order, so one could store the value in a variable with module scope, and only get it once per test file ... but one can run tests in parallel, in which case things would probably not work.\n\nThen do: ```npm run test``` You will see that the first test passes, but the second one fails, as one would think.  You can delete the second test.  You might want to create tests for other numbers, to make sure the function doesn't always return 42.\n\n## Function Testing for An API\n\nYour current application doesn't have an API, so you can add one by adding the following, at an appropriate place (like before the not found handler) to app.js:\n```javascript\napp.get(\"/multiply\", (req, res) => {\n  const result = req.query.first * req.query.second;\n  if (result.isNaN) {\n    result = \"NaN\";\n  } else if (result == null) {\n    result = \"null\";\n  }\n  res.json({ result: result });\n});\n```\nYou also have to change app.js to make your app available to the test.  The bottom of the file should look like:\n```javascript\nconst port = process.env.PORT || 3000;\nconst start = () => {\n  try {\n    require(\"./db/connect\")(mongoURL);\n    return app.listen(port, () =>\n      console.log(`Server is listening on port ${port}...`),\n    );\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nstart();\n\nmodule.exports = { app };\n```\nHere, to facilitate testing, we have made start() synchronous. You can try the multiply API out if you like, by starting the server and doing the following in your browser:\n```\nhttp://localhost:3000/multiply?first=5&second=27\n```\nThen create a test, a file tests/test_multiply_api.js, as follows:\n```javascript\nconst { app } = require(\"../app\");\nconst get_chai = require(\"../util/get_chai\");\n\ndescribe(\"test multiply api\", function () {\n  it(\"should multiply two numbers\", async () => {\n    const { expect, request } = await get_chai();\n    const req = request\n      .execute(app)\n      .get(\"/multiply\")\n      .query({ first: 7, second: 6 })\n      .send();\n    const res = await req;\n    expect(res).to.have.status(200);\n    expect(res).to.have.property(\"body\");\n    expect(res.body).to.have.property(\"result\");\n    expect(res.body.result).to.equal(42);\n  });\n});\n```\nNote first of all that this file actually requires your app, which causes your app to run.  You do not want your server running when you run the test, because the require() function for the app starts it.  Chai is going to send data to that running app.  The chai-http package adds HTTP functions to Chai, so it now has the get() method (as well as post, patch, etc.), and these return a request object with methods query and send. One can then check the result status and body.   Do ```npm run test``` to try it out.\n\n## Function Testing for Rendered HTML\n\nOf course, the application you are writing is not intended to provide an API.  Instead it provides rendered HTML pages.  You can test these as well.\n\nThere are two annoying problems to deal with, one in Chai and one in the Express rendering engine.  In Express, when a page is rendered, it should set the Content-Type response header to be text/html.  But it doesn't.  The second problem is that if Chai receives a response without the Content-Type header, it tries to parse it as JSON, and throws an error if that fails. It should catch the error, but it doesn't, which is crude.  You can fix the issue by setting the Content-Type header appropriately with this middleware, which should be added to app.js before your routes:\n```javascript\napp.use((req, res, next) => {\n  if (req.path == \"/multiply\") {\n    res.set(\"Content-Type\", \"application/json\");\n  } else {\n    res.set(\"Content-Type\", \"text/html\");\n  }\n  next();\n});\n```\nNow create a simple UI test case, in tests/test_ui.js:\n```javascript\nconst { app } = require(\"../app\");\nconst get_chai = require(\"../util/get_chai\");\n\ndescribe(\"test getting a page\", function () {\n  it(\"should get the index page\", async () => {\n    const { expect, request } = await get_chai();\n    const req = request.execute(app).get(\"/\").send();\n    const res = await req;\n    expect(res).to.have.status(200);\n    expect(res).to.have.property(\"text\");\n    expect(res.text).to.include(\"Click this link\");\n  });\n});\n```\nIn this case, you get a res.text, instead of a res.body.  The text is the actual HTML sent back in response to the request, as a string.  Checking the string to see if the response was correct can be a little clumsy, as compared with checking the results of an API.  Anyway, verify that your tests still pass, by doing ```npm run test```.  If you used slightly different wording in your page, you'll have to change the test above.\n\n## Testing Registration \n\nHere is a test for registration. You should put it in a file tests/registration_logon.js.\n```javascript\nconst { app } = require(\"../app\");\nconst { factory, seed_db } = require(\"../util/seed_db\");\nconst faker = require(\"@faker-js/faker\").fakerEN_US;\nconst get_chai = require(\"../util/get_chai\");\n\nconst User = require(\"../models/User\");\n\ndescribe(\"tests for registration and logon\", function () {\n  // after(() => {\n  //   server.close();\n  // });\n  it(\"should get the registration page\", async () => {\n    const { expect, request } = await get_chai();\n    const req = request.execute(app).get(\"/session/register\").send();\n    const res = await req;\n    expect(res).to.have.status(200);\n    expect(res).to.have.property(\"text\");\n    expect(res.text).to.include(\"Enter your name\");\n    const textNoLineEnd = res.text.replaceAll(\"\\n\", \"\");\n    const csrfToken = /_csrf\\\" value=\\\"(.*?)\\\"/.exec(textNoLineEnd);\n    expect(csrfToken).to.not.be.null;\n    this.csrfToken = csrfToken[1];\n    expect(res).to.have.property(\"headers\");\n    expect(res.headers).to.have.property(\"set-cookie\");\n    const cookies = res.headers[\"set-cookie\"];\n    this.csrfCookie = cookies.find((element) =>\n      element.startsWith(\"csrfToken\"),\n    );\n    expect(this.csrfCookie).to.not.be.undefined;\n  });\n\n  it(\"should register the user\", async () => {\n    const { expect, request } = await get_chai();\n    this.password = faker.internet.password();\n    this.user = await factory.build(\"user\", { password: this.password });\n    const dataToPost = {\n      name: this.user.name,\n      email: this.user.email,\n      password: this.password,\n      password1: this.password,\n      _csrf: this.csrfToken,\n    };\n    const req = request\n      .execute(app)\n      .post(\"/session/register\")\n      .set(\"Cookie\", this.csrfCookie)\n      .set(\"content-type\", \"application/x-www-form-urlencoded\")\n      .send(dataToPost);\n    const res = await req;\n    expect(res).to.have.status(200);\n    expect(res).to.have.property(\"text\");\n    expect(res.text).to.include(\"Jobs List\");\n    newUser = await User.findOne({ email: this.user.email });\n    expect(newUser).to.not.be.null;\n  });\n});\n\n```\nOk, there's a lot going on here. The test first gets the registration form.  So far so good. Then, the task is to post values for the form so that the user is actually registered.  But, to post a form, we have to get past the protection against cross site request forgery that you implemented in the last lesson.  To do that, we need the CSRF token, which appears in the form itself, but we have to find it. We can do that using a regular expression. First we take the line ends out of the form, as they mess up regular expression parsing. Then we execute a regular expression to find the token itself.  If you don't know regular expressions, they are good to learn, but otherwise just use the one herein provided. When we post the values for the form, we need to include the value for the csrf token. We store it in this.csrfToken, so that we can reuse the value.  The other half of the CSRF protection is that we also need to send the cookie.  Chai does not keep cookie values between tests. We have to preserve the ones we want, and include them on subsequent requests.  Chai doesn't even store the cookies in a very friendly way. We have to parse them out of the response headers, so there is more logic to do that. For each of these steps, we do a Chai assertion (expect) so that we know all is working.\n\nIf one of the expect() assertions fails, the rest of the code in that it() stanza does not run, but execution will continue with the next stanza.\n\n### A Reminder About Arrow Functions and Non-Arrow Functions\n\nYou will notice that we declare anonymous functions two different ways:\n```javascript\ndescribe(\"tests for registration and logon\", function () {\n```\nand\n```javascript\n  it(\"should get the registration page\", async () => {\n```\nThe difference is that arrow functions do not have their own \"this\"!  They inherit the this of the context in which they were defined. So, when we save to the variable this.csrfToken, we do it in the context of the describe().  On that call to describe, we pass ```function ()```, and so the this is associated with that context. As a result this.csrfToken is available on our next it() call within that same describe, so long as that call to it() passes an arrow function.  There are, of course, other ways to save the token, such is in a variable with module scope.\n\n## Posting the Form Values\n\nOk, so what do we post, and where do we post it? The post for register is /sessions/register.  If we look at the register view, we see what is expected, from the names of the entry fields.  These are name, email, password, and password1 (for password confirmation).  To get values for these, we can use the user factory created in util/seed_db.js.  But (a) we need to save the password, so that we can use it to test logon; (b) we need to save other values for the user, again for logon, and (c) we use factory.build, not factory.create, because we don't want the factory to store values in the database. That's what the actual register operation is supposed to do.\n\nWhen we post, we have to set the cookie for CSRF protection.  We also have to set the content-type, which would otherwise be JSON. We also have to include the csrfToken in the data that is posted, with the name _csrf.  We post the resulting information, and then search the database to verify that the user object was actually created.\n\nThere could be two kinds of it() statements;\n```javascript\n  it(\"should get the registration page\", (done) => {\n```\nand\n```javascript\n  it(\"should register the user\", async () => {\n```\nIn the first (old style) way, we pass a callback, the done() function, and that must be called at the completion of the test.  In the second way, we just declare an async function.  In our examples, we only use the second way, because we have to call get_chai(), which is asynchronous.\n\nIf the user is actually created, our controller sends a redirect.  By default, Chai traverses the redirect automatically, so that the res object coming back should have a status of 200.  It should redirect to the index page, and on that page one should see \"Click this link to logon\".\n\n### An Aside on Status Codes\n\nWhen the controller gets an error from a post, it can render the page again\n```javascript\n      req.flash(\"error\", \"That email address is already registered.\");\n      return res.status(400).render(\"register\", { errors: req.flash(\"error\") });\n```\nBe careful to include the status(400).  If the status is 200, the request is expected to have succeeded.  Check your render statements to make sure that if there is an error condition, the 400 status code is set.  I think I provided some code in earlier lessons that did not do that.\n\n## Testing Logon\n\nWe saved this.user and this.password, so we should be able to log in.  We'll skip actually loading the logon form -- you could add that test if you like -- and we'll do the post for logon.  When you logon, you are redirected.  By default, Chai then follows the redirection, but what it doesn't do is keep the cookies.  When you do the .send for the test, the cookies are already gone.  This is completely useless for logon. We need the session cookie for subsequent requests.  It is pretty poor in another way.  If you redirect, the session contains the flash information for user messages, but if the cookies are gone, so are the flash messages.  So, a better policy is to disable redirects by doing .redirects(0) on the request. If a redirect occurs, the status is 302, and the req.headers.location is the target for the redirect.  (Editorial aside: Chai really ought to save those cookies.) So, here is the logon test, which should be added to the previous describe() section:\n```javascript\n  it(\"should log the user on\", async () => {\n    const dataToPost = {\n      email: this.user.email,\n      password: this.password,\n      _csrf: this.csrfToken,\n    };\n    const { expect, request } = await get_chai();\n    const req = request\n      .execute(app)\n      .post(\"/session/logon\")\n      .set(\"Cookie\", this.csrfCookie)\n      .set(\"content-type\", \"application/x-www-form-urlencoded\")\n      .redirects(0)\n      .send(dataToPost);\n    const res = await req;\n    expect(res).to.have.status(302);\n    expect(res.headers.location).to.equal(\"/\");\n    const cookies = res.headers[\"set-cookie\"];\n    this.sessionCookie = cookies.find((element) =>\n      element.startsWith(\"connect.sid\"),\n    );\n    expect(this.sessionCookie).to.not.be.undefined;\n  });\n\n  it(\"should get the index page\", async () => {\n    const { expect, request } = await get_chai();\n    const req = request\n      .execute(app)\n      .get(\"/\")\n      .set(\"Cookie\", this.csrfCookie)\n      .set(\"Cookie\", this.sessionCookie)\n      .send();\n    const res = await req;\n    expect(res).to.have.status(200);\n    expect(res).to.have.property(\"text\");\n    expect(res.text).to.include(this.user.name);\n  });\n```\nThere are two parts to the test.  The first does the logon.  You get a redirect ... but it will redirect to the same place whether the logon succeeds or fails.  And you will have a session cookie even before you log in.  So how do you know whether the logon succeeded?  The only way is to get the index page again.  If the logon is successful, it will show the user's name, but if not, it will show the error message.  To do this, we have to include the session cookie in the request, as we do above.\n\n**Now: Some code for you to write.**  Create a test for logoff.  Logoff won't work unless there has been a logon, and unless you send the _csrf value and set cookies for both the csrfToken and the sessionCookie.  The latter code is:\n```javascript\n.set(\"Cookie\", this.csrfToken + \";\" + this.sessionCookie)\n```\nYou need to post data, as before, but the only field in the data is ```_csrf```.  In this case, you let Chai follow the redirect, that is, do not do ```.redirects(0)```. You should get back a page that includes \"link to logon\".\n\n## Testing Job CRUD Operations\n\nCreate a new file, tests/crud_operations.js.  You will need a couple of extra require() statements, as follows:\n```javascript\nconst Job = require(\"../models/Job\")\nconst { seed_db, testUserPassword } = require(\"../util/seed_db\");\n```\nThe flow for testing CRUD operations is as follows.\n\n1. Seed the database! You have a utility routine for that in util/seed_db.js\n2. Logon! You will have to get the logon page to get the CSRF token and cookie. The seed_db.js module has a function to seed the database with a user entry, and it also exports the user's password, so you can use those. You'll need to save the session cookie.  Steps 1 and 2 are not tests, but you need an async before() call, inside your describe(), that does these things.  Here is the before() that completes steps 1 and 2:\n    ```javascript \n      before(async () => {\n        const { expect, request } = await get_chai();\n        this.test_user = await seed_db();\n        let req = request.execute(app).get(\"/session/logon\").send();\n        let res = await req;\n        const textNoLineEnd = res.text.replaceAll(\"\\n\", \"\");\n        this.csrfToken = /_csrf\\\" value=\\\"(.*?)\\\"/.exec(textNoLineEnd)[1];\n        let cookies = res.headers[\"set-cookie\"];\n        this.csrfCookie = cookies.find((element) =>\n          element.startsWith(\"csrfToken\"),\n        );\n        const dataToPost = {\n          email: this.test_user.email,\n          password: testUserPassword,\n          _csrf: this.csrfToken,\n        };\n        req = request\n          .execute(app)\n          .post(\"/session/logon\")\n          .set(\"Cookie\", this.csrfCookie)\n          .set(\"content-type\", \"application/x-www-form-urlencoded\")\n          .redirects(0)\n          .send(dataToPost);\n        res = await req;\n        cookies = res.headers[\"set-cookie\"];\n        this.sessionCookie = cookies.find((element) =>\n          element.startsWith(\"connect.sid\"),\n        );\n        expect(this.csrfToken).to.not.be.undefined;\n        expect(this.sessionCookie).to.not.be.undefined;\n        expect(this.csrfCookie).to.not.be.undefined;\n      });\n    ```\n3. Get the job list! You have to include the session cookie with your get request. The seed operation stores 20 entries. Your test should verify that a status 200 is returned, and that exactly 20 entries are returned.  That's a little complicated for an html page, but in this case, you can just check how many times \"<tr>\" appears on the page.  Here's how you might do that part:\n    ```javascript\n    const pageParts = res.text.split(\"<tr>\")\n    expect(pageParts).to.equal(21)\n    ```\n    As you can see, scanning the page to see if the result is correct is kind of messy.\n4. Add a job entry! This is a post for the job form. You will have to include _csrf in the post, and you will need to set the CSRF and session cookies.  You could use the factory to create values for the job, via a factory.build('job'). The best way to test for success is to see that the database now has 21 entries, as follows:\n    ```javascript\n        const jobs = await Job.find({createdBy: this.test_user._id})\n        expect(jobs.length).to.equal(21)\n    ```\n\n## Puppeteer\n\nIn actual practice, chai-http is mostly used for testing APIs. To test a user interface, whether it be server side rendered or full stack, one would use an actual browser testing engine such as puppeteer.  Create a file, tests/puppeteer.js, with the following contents:\n```javascript\nconst puppeteer = require(\"puppeteer\");\nrequire(\"../app\");\nconst { seed_db, testUserPassword } = require(\"../util/seed_db\");\nconst Job = require(\"../models/Job\");\n\nlet testUser = null;\n\nlet page = null;\nlet browser = null;\n// Launch the browser and open a new blank page\ndescribe(\"jobs-ejs puppeteer test\", function () {\n  before(async function () {\n    this.timeout(10000);\n    //await sleeper(5000)\n    browser = await puppeteer.launch();\n    page = await browser.newPage();\n    await page.goto(\"http://localhost:3000\");\n  });\n  after(async function () {\n    this.timeout(5000);\n    await browser.close();\n  });\n  describe(\"got to site\", function () {\n    it(\"should have completed a connection\", async function () {});\n  });\n  describe(\"index page test\", function () {\n    this.timeout(10000);\n    it(\"finds the index page logon link\", async () => {\n      this.logonLink = await page.waitForSelector(\n        \"a ::-p-text(Click this link to logon)\",\n      );\n    });\n    it(\"gets to the logon page\", async () => {\n      await this.logonLink.click();\n      await page.waitForNavigation();\n      const email = await page.waitForSelector('input[name=\"email\"]');\n    });\n  });\n  describe(\"logon page test\", function () {\n    this.timeout(20000);\n    it(\"resolves all the fields\", async () => {\n      this.email = await page.waitForSelector('input[name=\"email\"]');\n      this.password = await page.waitForSelector('input[name=\"password\"]');\n      this.submit = await page.waitForSelector(\"button ::-p-text(Logon)\");\n    });\n    it(\"sends the logon\", async () => {\n      testUser = await seed_db();\n      await this.email.type(testUser.email);\n      await this.password.type(testUserPassword);\n      await this.submit.click();\n      await page.waitForNavigation();\n      await page.waitForSelector(`p ::-p-text(${testUser.name} is logged on.)`);\n      await page.waitForSelector(\"a ::-p-text(change the secret)\");\n      await page.waitForSelector('a[href=\"/secretWord\"]');\n      const copyr = await page.waitForSelector(\"p ::-p-text(copyright)\");\n      const copyrText = await copyr.evaluate((el) => el.textContent);\n      console.log(\"copyright text: \", copyrText);\n    });\n  });\n});\n```\nIn each of the describe() stanzas, as well as in before() and after(), we call this.timeout() to set a reasonable number of milliseconds after which the operation should be abandoned.  The puppeteer.launch() call actually launches the browser, which by default is a version of Chrome.  The browser.newPage() call opens up a browser page.  The page.goto() call opens the root page of the application being tested.  Then, we have the following calls:\n\n- page.waitForSelector(): Waits for DOM entry matching the selector to appear on the page.\n- page.waitForNavigation(): Waits for the next page to display.\n- entry.type(): Types a value into an entry field.\n- entry.click(): Clicks on a button or other control.\n\nYou can see that these allow you to traverse the application, and there are other operations as well, which you can find in the online documentation for puppeteer [here](https://pptr.dev/).  The waitForSelector() function takes one argument, which is the selector.  These come in two flavors:\n\n- CSS style selectors: ```await page.waitForSelector('a[href=\"/secretWord\"]');```.  This finds a link to the /secretWord page.\n- P selectors, a puppeteer add on: ```await page.waitForSelector(\"p ::-p-text(copyright)\");``` This one finds a paragraph element with the text \"copyright\" in it.\n\nThe test uses these to click on the link for the logon page, to fill out the page, and to verify that the right page came back and the logon completed.  The seed_db utility is used to create a user that is used for the logon, and to create some job entries belonging to that user.  Run ```npm run test``` to verify that all still works.\n\nNow, if you like, you can watch the process.  If you change the puppeteer.launch() statement to read\n```\npuppeteer.launch({headless: false, slowMo: 100})\n```\nand then rerun the test, you'll see the test in progress.  However, an aside for Windows users: If you are in the habit of doing your development in the  Windows Linux Subsystem, the headless:false may or may not work.\n\n## More Code to Write\n\nThe test you are to add is to verify that the job operations work correctly.  You will need to add the expect function from Chai to the test.  You can do:\n```\nconst { expect } = await import('chai')\n```\nbut as this is an async call, you can only do this in the it() sections where you need it.\n1. Add a new describe(\"puppeteer job operations\" ...) stanza for this series of tests.\n2. (test1) Make the test do a click on the link for the jobs list.  Verify that the job listings page comes up, and that there are 20 entries in that list.\n      A hint here: page.content() can be used to get the entire HTML page, and you can use the split() function on that to find the ```<tr>```entries.\n3. (test2) Have the test click on the \"Add A Job\" button and to wait for the form to come up.  Verify that it is the expected form, and resolve the company and position fields and add button.  \n4. (test3) Type some values into the company and position fields.  Then click on the add button. Wait for the jobs list to come back up, and verify that the message says that the job listing has been added.  Check the database to see that the latest jobs entry has the data entered. You also use Job.find() as in the previous exercise.)\n\n## Submit Your Code\n\nAs usual.",
            "codeExample": "",
            "_id": "68f27f4b71abd9d6b34f6a95"
          }
        ],
        "submissionInstructions": "Please submit on time",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Introduction",
          "content": "Any large development project requires automated testing to ensure components work correctly, that they work well together, and that nothing is broken as the application is maintained and as features are added.  The testing also ensures that the program works to specifications.  Manual testing with Postman or other tools is time consuming and error prone.  This lesson gives practice in developing an API and shows how to do automated Express testing.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a90"
        },
        {
          "subsectionOrder": 2,
          "title": "Types of Testing",
          "content": "1. Unit Tests: These are very low level tests of an individual method, class, or module.\n2. Integration Tests: These verify that the different parts of the application work well together.\n3. Functional or System Tests: These verify that the application produces the required output, each of the components working together.\n\nThere is also performance testing, acceptance testing, security testing etc.  But for the developer, the following three types of tests are the main ones.  In some cases, the tests are written before the development begins, based on the application spec.  In any case, as software developers, you will be asked to develop tests, and frequently you will be required to provide tests for any code you submit.  By the way, your functional tests for production applications **should include security testing**, to avoid having security holes.  Security tests make sure that the user is authenticated and authorized to access the information provided.\n\nFor Node/Express, there are several standard testing tools. Mocha is a testing framework that automates the running of tests.  Chai is an assertion framework, which provides testing specific language extensions that allow you to describe the expected output and to record errors if the results are not as exprected.  You will also need to test the web front end.  Several Node based tools for this purpose are Puppeteer and Cypress.  We will use Puppeteer.  These examine the web pages that are returned, fill in forms, and submit input as a user would.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a91"
        },
        {
          "subsectionOrder": 3,
          "title": "Introducing Mocha and Chai",
          "content": "Here is a sample test case that uses Mocha and Chai.  It won't work for the present lesson, because it is for calling an API, not getting a page.\n\n```javascript\ndescribe(\"Jobs\", function () {\n  describe(\"GET /jobs\", function () {\n  // Test to get all jobs belonging to the logged on user\n    it(\"should get all jobs for the user\", async () => {\n      // We need to get the values for request and expect here.\n      // More on that later.\n      const req = request.execute(app)\n        .get('/api/v1/jobs')\n        .send()\n      const res = await req()\n      expect(res).to.have.status(200);\n      expect(res.body).to.be.a('object');\n      expect(res.body.jobs.length).to.equal(3); // or whatever is in your test data\n    });  \n         ...\n```\nThe Mocha keywords here are \"describe\" and \"it\".  These organise the test suite into blocks and document the purpose of each test case.  The test above is not really complete, in that one would want to verify that\nthe expected data is returned.  And, as written, the test would fail, or at least would return an empty object, because of course, no user is logged in.  So Mocha provides some additional keywords: before, beforeEach, after, and afterEach.  These are for things such as logon to be done before or after a given block, or before or after each test case in the block.\n\nThe chai-http words here are, in this case, get, which returns a result or an error.  Of course there are put, post, patch, and delete as well. The get function is implemented in chai-http.  The Chai word we are using is expect, which checks that the result is correct.\n\nSome other things to think about: We have been using a single Mongo database for development. Were you building an actual production application, you would want separate databases for development, test, and production.  Also, for testing, you would want a way to populate the database with sample data, so that it is in a known state at the start of the test.  For this purpose, we'll use an npm package called factory-bot.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a92"
        },
        {
          "subsectionOrder": 4,
          "title": "A Short Introduction to Puppeteer",
          "content": "With Puppeteer, you actually load the pages, find the HTML elements on the page, and interact with them, using a browser engine, which is typically Chrome.  You can run Chrome in \"headless\" mode, but if you do not do this, you can actually watch your test typing values into a browser window. Puppeteer involves a lot of async/await.  Here is the start of a Puppeteer test, where the connection to the browser is made and a\npage is retrieved:\n```javascript\n  describe(\"Functional Tests with Puppeteer\", function () {\n    let browser = null;\n    let page = null;\n    before(async function () {\n      this.timeout(5000);\n      browser = await puppeteer.launch();\n      page = await browser.newPage();\n      await page.goto(\"http://localhost:3000\");\n    });\n    after(async function () {\n      this.timeout(5000);\n      await browser.close();\n      return;\n    });\n    describe(\"got to site\", function () {\n      it(\"should have completed a connection\", async () => {\n      });\n    });\n    describe(\"people form\", function () {\n      this.timeout(5000);\n      it(\"should have various elements\", async () => {\n        this.nameField = await page.waitForSelector(\"input[name=\\\"name\\\"]\");\n        this.ageField = await page.waitForSelector(\"input[name=\\\"age\\\"]\");\n        this.addPerson = await page.waitForSelector(\"button ::-p-text(Add)\")\n```\nIn the above code, this.timeout(5000) sets the timeout for that test, the amount of time by which the operation certainly should have succeeded.  We can verify that the page came up with some entry fields, identified by their HTML IDs or other attributes. To find the button, we use some special syntax provided by Puppeteer, to find a button with \"Add\" in the text.\n\nThen, we can start interacting with the form, as follows:\n```javascript\n      it(\"should create a person record given name and age\", async () => {\n        await this.nameField.type(\"Fred\");\n        await this.ageField.type(\"10\");\n        await this.addPerson.click();\n        await page.waitForNavigation();\n        const resultDataDiv = await page.waitForSelector(\"#result\");\n        const resultData = await resultDataDiv.evaluate((element) => element.textContent);\n        expect(resultData).to.include(\"A person record was added\");\n        ...\n```\nHere you see the code that actually types into entry fields, and then clicks on the submit button.  You get the idea.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a93"
        },
        {
          "subsectionOrder": 5,
          "title": "Goals of the Lesson",
          "content": "You are seeing several kinds of integration/functional testing, involving either direct communication with the controllers (Chai), or communication with the web GUI (Puppeteer).  In each case, the tests cause interaction with the running Express server.  In this lesson, you learn to write these tests.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a94"
        }
      ]
    },
    {
      "id": "68f27f4b71abd9d6b34f6a97",
      "lessonNumber": 16,
      "title": "FERRET: Node/Express Class",
      "status": "pending",
      "assignment": {
        "title": "Assignment",
        "objective": "No objective provided",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [],
        "submissionInstructions": "Please submit your work by the deadline",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Introduction",
          "content": "# FERRET: Node/Express Class\n\nWelcome to the Code the Dream’s Node/Express class, Ferret! \n\nNode, short for Node.js, is an implementation of the Chrome JavaScript engine, but one that runs outside of the browser, so that it can be used to write standalone programs as well as web serving applications. Express is a framework for Node that makes the creation of web applications very easy. These are complemented by a vast library of NPM packages to make adding common functions easy. The combination is a leading framework throughout the IT industry, and continues to grow in adoption. And, all programming in Node and Express is in JavaScript, so the back end engine for an application can be written in the same language as the front end.\n\nBelow is a quick outline of this course. Remember to keep pace with the mentor sessions, and don’t hesitate to ask lots of questions! Slack is the best place for your questions, and you have a Slack channel for that purpose ([#ferret-discussion](https://codethedream.slack.com/archives/C05QUGWCJHL)). Get oriented on the [**Student Resources** ](http://www.learn.codethedream.org/student-resources)page. [See below for information on mentor sessions.](https://learn.codethedream.org/ferret-node/#ferret-mentors)\n\n**If you need assistance with non-curriculum items please contact your Cohort Instructional Leader, Chase Allman-Knieper, on [Slack](https://codethedream.slack.com/team/U0535FFH3CN) or by this email:** [ferret@codethedream.org](mailto:ferret@codethedream.org)",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a98"
        },
        {
          "subsectionOrder": 2,
          "title": "Course Calendar",
          "content": "| **Week**     | **Start Date** | **Due Date**                                                                                                                                                                                                                               | **Lessons**                                                                                                                                                                                                                    |\n| ------------ | -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Pre-Class    | Sept 26, 2023  | **[Machine Setup](./getting-started-with-node-development.md)** **[Github Cookbook](https://learn.codethedream.org/git-and-github-starter/)**[**Gear up for Class**](https://learn.codethedream.org/pre-class/) |                                                                                                                                                                                                                                |\n| 1            | Sept 27, 2023  | Oct 3, 2023                                                                                                                                                                                                                                | **[Node Introduction](./ctd-node-lesson-1.md)**                                                                                                                                 |\n| 2            | Oct 4, 2023    | Oct 10, 2023                                                                                                                                                                                                                               | **[NPM and Async Patterns](./ctd-node-lesson-2.md)**                                                                                                                                     |\n| 3            | Oct 11, 2023   | Oct 17, 2023                                                                                                                                                                                                                               | **[Introduction To Express](./ctd-node-lesson-3.md)**                                                                                                                                    |\n| 4            | Oct 18, 2023   | Oct 24, 2023                                                                                                                                                                                                                               | **[](./ctd-node-lesson-4.md)**[****Middleware, REST Methods,**  ****and Postman**](./ctd-node-lesson-4.md) |\n| 5            | Oct 25, 2023   | Oct 31, 2023                                                                                                                                                                                                                               | **[Task Manager API Part 1](./ctd-node-lesson-5.md)**                                                                                                                                    |\n| 6            | Nov 1, 2023    | Nov 7, 2023                                                                                                                                                                                                                                | **[Task Manager API Part 2](./ctd-node-lesson-6.md)**                                                                                                                                     |\n| 7            | Nov 8, 2023    | Nov 14, 2023                                                                                                                                                                                                                               | **[Using Query Parameters](./ctd-node-lesson-7.md)**                                                                                                                                      |\n| 8            | Nov 15, 2023   | Nov 21, 2023                                                                                                                                                                                                                               | **[JWT Basics](./ctd-node-lesson-8.md)**                                                                                                                                                  |\n| –            | Nov 22, 2023   | Nov 28, 2023                                                                                                                                                                                                                               | **HOLIDAY**                                                                                                                                                                                                                    |\n| 9            | Nov 29, 2023   | Dec 5, 2023                                                                                                                                                                                                                                | **[Jobs API Part 1](./ctd-node-lesson-9.md)**                                                                                                                                             |\n| 10           | Dec 6, 2023    | Dec 12, 2023                                                                                                                                                                                                                               | **[Jobs API Part 2](./ctd-node-lesson-10.md)**                                                                                                                                            |\n| 11           | Dec 13, 2023   | Dec 19, 2023                                                                                                                                                                                                                               | **Catch Up Week**                                                                                                                                                                                                              |\n| –            | Dec 20, 2023   | Jan 2, 2024                                                                                                                                                                                                                                | **HOLIDAY**                                                                                                                                                                                                                    |\n| 12           | Jan 3, 2024    | Jan 9, 2024                                                                                                                                                                                                                                | **[A Front End for the Jobs API](./ctd-node-lesson-11.md)**                                                                                                                               |\n| 13           | Jan 10, 2024   | Jan 16, 2024                                                                                                                                                                                                                               | **[Server Side Rendering with EJS](./ctd-node-lesson-12.md)**                                                                                                                             |\n| 14           | Jan 17, 2024   | Jan 23, 2024                                                                                                                                                                                                                               | **[Authentication with Passport](./ctd-node-lesson-13.md)**                                                                                                                               |\n| 15           | Jan 24, 2024   | Jan 30, 2024                                                                                                                                                                                                                               | **[Using EJS in a Database ](./ctd-node-lesson-14.md)** **[Application](./ctd-node-lesson-14.md)**                                                   |\n| 16           | Jan 31, 2024   | Feb 6, 2024                                                                                                                                                                                                                                | [Final Project Begins](https://learn.codethedream.org/node-express-final-project-latest/)                                                                                                                                      |\n| 17           | Feb 7, 2024    | Feb 13, 2024                                                                                                                                                                                                                               | Final Project Completed                                                                                                                                                                                                        |\n| Feb 14, 2024 | Feb 16, 2024   | Final Project Presentations                                                                                                                                                                                                                |                                                                                                                                                                                                                                |\n| Mar 4, 2024  | TBD            | Practicum                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                |",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a99"
        },
        {
          "subsectionOrder": 3,
          "title": "Before You Begin",
          "content": "You should plan to use the VSCode editor for this course. You should already know how to access your terminal. Refer to the Pre-Class week above to help with any environment setup.\n\n**[This is a cheat sheet for some of the concepts of this course.](https://learn.codethedream.org/cheat-sheet-for-the-node-express-class/)**",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a9a"
        },
        {
          "subsectionOrder": 4,
          "title": "Submitting Your Assignments",
          "content": "For each lesson, you will have a coding assignment and a mindset assignment. Follow the coding assignment instructions and make changes to your code as instructed. You should have basic familiarity with git before starting this course, but if you aren’t confident in your git skills, see this **[Github Cookbook.](https://learn.codethedream.org/git-and-github-starter/)** For each assignment, you will do the following steps:\n\n1. Create a branch for your lesson. Commit changes to that branch periodically, and push it to GitHub.\n2. When the lesson is complete and all your work has been pushed to GitHub, open a pull request for your branch. **Note: The target for your pull request should be the main branch of your own repository, not the Code-the-Dream-School Repository.**\n3. Then use the Assignment Submission Form to submit the link to your pull request, your mindset answers, and feedback.\n\nPlease review the homework submission tips at [**this link**](https://learn.codethedream.org/tips-on-submitting-your-homework/) before you begin.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a9b"
        },
        {
          "subsectionOrder": 5,
          "title": "When Submitting Your Code",
          "content": "When you submit your code, it should be working. If you are not able to get your code working, ask for help on Slack, or bring up questions in a mentor session, or arrange a 1:1 mentor session.\n\nAll code should be readable. There are many aspects to good code style, but the most important for right now is indentation! The content of blocks, methods, and classes should be indented two spaces. The end statement should line up, being indented the same number of spaces, with the statement that begins the block, method, or class. Here’s an example:\n\n```\nfunction my_function(parameter) {\n  if (x === 0) {\n    return x;\n  else {\n    return error;\n  }\n}\n```\n\nWe need proper indentation in order to be able to review your assignments. You need proper indentation to make sure your code is structured correctly. There are two npm packages that will help you (once you know how to use npm): prettier and eslint. Prettier can reformat your code. Eslint can find syntax errors and bad practices.\n\nHaving useful commenting in your code is also advised. It helps you, your reviewer, and anyone else who may work with your code find needed areas during review or debugging. Here’s an example of a useful comment on the example code from above:\n\n```\n//ERROR CATCH FUNCTION\nfunction my_function(parameter) {\n  if (parameter === 0) {\n    return parameter;\n  else {\n    throw new Error(\"Failure occurred.\");\n  }\n}\n```",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a9c"
        },
        {
          "subsectionOrder": 6,
          "title": "Final Project",
          "content": "For the final project, each student implements an Express application that includes authentication and CRUD operations to a MongoDB database. The application may be implemented as APIs plus a front end (full stack) or using Server Side Rendering with EJS templates. The rubric is below:\n\n**[Rubric for Express Final Project](https://learn.codethedream.org/node-express-final-project-latest/)**\n\nA sample final project is described **[here.](https://learn.codethedream.org/a-sample-node-express-project/)** The provided sample is for EJS, but all students should read the description at the link, as it provides an important introduction to security in web applications. Look at the rubric for a warning about reusing this code.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a9d"
        },
        {
          "subsectionOrder": 7,
          "title": "Mentor Session Calendar / Links",
          "content": "**Group Instructors**\n\nGroup Instructors are volunteer mentors who will host one or more one-hour long group sessions weekly. **You do not need to sign up for the sessions** anymore; the mentors will inform Code the Dream or your attendance. **You must attend a minimum of 1 session (group or 1:1) each week.** The mentor session schedule for your class can be found here: [Ferret Mentor Session Schedule](https://docs.google.com/document/d/1LGIN7U0ksxVsPj7SZ%5FgDFmcavKpF7%5Fl%5FLesvqIT4fs8/edit?usp=sharing)\n\n**1:1 (One-on-One) Mentors**\n\nOne-on-One Mentors are volunteer mentors who will be assigned specific students. They will be reviewing your assignments as you turn them in and will be reaching out to you by Slack every week to see how you’re doing with the materials/lessons. Feel free to reach out to them by direct messaging them on Slack if you have questions you need help with outside of group sessions. If you have more than a quick question for them, please schedule an appointment with them using the links on the session schedule sheet. If your assigned mentor is unavailable when you are, please reach out to any of the other 1:1 mentors with availability that matches yours.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6a9e"
        }
      ]
    },
    {
      "id": "68f27f4b71abd9d6b34f6aa0",
      "lessonNumber": 17,
      "title": "Getting Started with Node Development",
      "status": "pending",
      "assignment": {
        "title": "Assignment",
        "objective": "No objective provided",
        "expectedCapabilities": [],
        "instructions": [],
        "tasks": [],
        "submissionInstructions": "Please submit your work by the deadline",
        "checklist": [],
        "checkForUnderstanding": []
      },
      "subsections": [
        {
          "subsectionOrder": 1,
          "title": "Introduction",
          "content": "# Getting Started with Node Development\n\nWelcome to Code the Dream’s Node/Express class! You will be learning Node, an implementation of the JavaScript engine that runs standalone or as a web server. This page describes how to begin.\n\nYou can develop Node applications on MacOS, Linux, or Windows. If you are developing on Windows, there is no need to do development in a virtual machine, as Node development works fine in Windows native environments.\n\nYou will need the git program. This is typically already present on MacOS and Linux. You can run\n\n```\ngit --version\n```\n\nto see if it is installed. On Windows, you should install Git for Windows, if you haven’t already. It is available **[here.](https://gitforwindows.org/)** \n\nYou will also need an editor. For JavaScript development the VSCode editor is strongly recommended.\n\nFinally, you will need to install Node and the Node Package Manager npm. That package is available **[here](https://nodejs.org/en/download/)**. You should install the latest LTS version.\n\nThe other package you need is called Postman. In this class, you create REST APIs. You may have no front end for those APIs, so you need to test them with Postman. The Postman package is available **[here](https://www.postman.com/downloads/)**.\n\nMacOS and Linux users can skip the next section — but please continue with the Your Assignments section below.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6aa1"
        },
        {
          "subsectionOrder": 2,
          "title": "Windows Setup",
          "content": "A few additional steps are recommended when setting up a Windows machine for Node development. When you install Git for Windows, you get a terminal shell program called Git Bash. This is the terminal environment you should use for Node development. Do not use cmd.exe or PowerShell, as these terminal environments work differently. With Git Bash, your terminal will work like the LInux or MacOS terminals, so you can enter the same commands as the students with Linux or MacOS. It helps to have some basic understanding of these shell commands: cd, ls, mkdir, touch, pwd. If you are not familiar with these, there is a tutorial **[here](https://ubuntu.com/tutorials/command-line-for-beginners#1-overview)**.\n\nYou should always start a Git Bash session to issue git, node, or npm commands. You should also configure git to handle line endings in the Linux way, via these commands:\n\n```\ngit config --global core.eol lf\ngit config --global core.autocrlf input\n```\n\nYou should also configure npm to integrate with Git Bash. This is done with the following command:\n\n```\nnpm config set script-shell \"C:\\\\Program Files\\\\git\\\\bin\\\\bash.exe\"\n```\n\nYou should also configure VSCode to handle line ends as Linux does, and to use Git Bash as the terminal shell. Start VSCode from your Git Bash session by typing\n\n```\ncode .\n```\n\nYou can then bring up the settings for VSCode by typing Ctrl, (the ctrl key plus the comma). The settings has a Search settings entry field. Type line end in that entry field. You will then be able to set the Eol to /n which is what you want. Then do a Search settings for: terminal integrated default profile windows. This brings up a dropdown, from which you should choose Git Bash.\n\nThat completes Windows specific setup.",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6aa2"
        },
        {
          "subsectionOrder": 3,
          "title": "Your Assignments",
          "content": "For each of the assignments, you will have a starter Git repository. To do the assignments, you will have to have a github account, if you don’t have one already. You open the link to the starter repository, and click on the fork button in the upper right to make a fork of that repository in your own github account. Then, you clone your fork of the repository to your development workstation. This is done with the git clone command, passing the URL of your repository. It is important that you clone from your fork, and not from the starter repository.\n\nAfter you have cloned, you cd to the directory created when you cloned. You then create a new git branch for your work. For example, for the week 1 assignment, you would enter the command\n\n```\ngit checkout -b week1\n```\n\nwhich will create the week1 branch. You should do this before doing any of the work for the assignment. You then cd to the directory where you will be working, and type code . to bring up VSCode for that directory. For the early assignments, you will be following along with an instructor in a video, repeating the same coding he is doing.\n\nWhen you have finished the week’s assignment, you push it to github as follows:\n\n```\ngit status\ngit add -A\ngit commit -m \"Week 1 assignment\"\ngit push origin week1\n```\n\nYou then go to your github and open your fork of the repository. You create a pull request. The target of the pull request must be the main branch of your fork. Then you use the assignment submission form. A link to this form is in the assignment page. You include a link to your pull request in the assignment submission form.\n\nFor the first few weeks, you will use the same repository for several weeks of work. Each week’s work must be in a different git branch, and you create the week2 branch from the week1 branch so that each week builds on the work from the weeks before.\n\n## Good Luck With the Class, and Happy Coding!",
          "videoUrl": "",
          "codeExamples": [],
          "externalLinks": [],
          "quizzes": [],
          "_id": "68f27f4b71abd9d6b34f6aa3"
        }
      ]
    }
  ]
}